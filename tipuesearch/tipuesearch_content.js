var tipuesearch = {"pages":[{"title":" FEATS ","text":"FEATS ![Sourcery Institute][sourcery-institute logo]\n\n\nFramework for Extensible Asynchronous Task Scheduling (FEATS)\n=============================================================\n\n[![GitHub license][license img]](./LICENSE)\n[![GitHub release][release img]](https://github.com/sourceryinstitute/FEATS/releases/latest)\n[![Download as PDF][pdf img]](https://md2pdf.herokuapp.com/sourceryinstitute/FEATS/blob/master/README.pdf)\n\n[Overview](#overview) | [Getting Started](#getting-started) | [Documentation](#documentation) | [Dependencies](#dependencies) | [Acknowledgments](#acknowledgments) | [Donate](#donate) Overview FEATS is a project to develop a parallel Fortran 2018 asynchronous, task-scheduling\nframework for use in a range of applications.  Our initial target application will be OLTARIS .  The aim is to assign one image per team of images the role of scheduler\nwith the remaining images serving as compute images.  The scheduler hands out tasks\nin an order that respects a directed acyclic graph (DAG) of task dependencies. Getting Started Please see the example directory for a demonstration use case in which FEATS traverses\na DAG that describes the module dependencies within FEATS itself and reports on task\ncompletion at each step.  In this simple example, the task completion is simply printing\nwhat file could have been compiled at the corresponding step.  No actual compiling happens,\nbut this use case describes what would happen if FEATS were to be used to enable the\n Fortran Package Manager [ fpm ] to perform parallel builds. With fpm , the GNU Fortran compiler ([ gfortran ]), and OpenCoarrays installed, build \nFEATS and run the example program by executing the following command in a bash -like \nshell: git clone https://github.com/sourceryinstitute/FEATS\ncd FEATS\nfpm run --example --compiler caf --runner \"cafrun -n 4\" Change 4 above to the number of images that you would like to launch in parallel. Documentation Please visit the FEATS GitHub Pages site to see HTML documentation generated \nwith [ ford ]. Dependencies The [ fpm.toml ] manifest describes the FEATS user and developer dependencies\nand directs fpm to download and build the dependency packages automatically. Testing To build and execute the FEATS test suite, run the following command in a bash -like shell: fpm test --compiler caf --runner \"cafrun -n 4\" Please report any test failures or other issues . Acknowledgments We gratefully acknowledge support from NASA Langley Research Center under contract number 80NSSC20P2246. Donate If you find this software useful, please consider donating code or currency to aid in development efforts. [![GitHub forks](https://img.shields.io/github/forks/sourceryinstitute/FEATS.svg?style=social&label=Fork)](https://github.com/sourceryinstitute/FEATS/fork)\n[![GitHub stars](https://img.shields.io/github/stars/sourceryinstitute/FEATS.svg?style=social&label=Star)](https://github.com/sourceryinstitute/FEATS)\n[![GitHub watchers](https://img.shields.io/github/watchers/sourceryinstitute/FEATS.svg?style=social&label=Watch)](https://github.com/sourceryinstitute/FEATS) Developer Info Damian Rouson, Robert Singleterry, Harris Snyder, and Brad Richardson","tags":"home","loc":"index.html"},{"title":"application_m.f90 – FEATS","text":"This file depends on sourcefile~~application_m.f90~~EfferentGraph sourcefile~application_m.f90 application_m.f90 sourcefile~task_item_m.f90 task_item_m.f90 sourcefile~application_m.f90->sourcefile~task_item_m.f90 sourcefile~task_m.f90 task_m.f90 sourcefile~task_item_m.f90->sourcefile~task_m.f90 sourcefile~payload_m.f90 payload_m.f90 sourcefile~task_item_m.f90->sourcefile~payload_m.f90 sourcefile~task_m.f90->sourcefile~payload_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~application_m.f90~~AfferentGraph sourcefile~application_m.f90 application_m.f90 sourcefile~image_m.f90 image_m.f90 sourcefile~image_m.f90->sourcefile~application_m.f90 sourcefile~application_s.f90 application_s.f90 sourcefile~application_s.f90->sourcefile~application_m.f90 sourcefile~image_s.f90 image_s.f90 sourcefile~image_s.f90->sourcefile~image_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules application_m Source Code application_m.f90 Source Code module application_m use dag_m , only : dag_t use task_item_m , only : task_item_t implicit none private public :: application_t type application_t !! A complete representation of an application that can be executed by FEATS private type ( dag_t ) dag_ !! Describes the dependencies between tasks type ( task_item_t ), allocatable :: tasks_ (:) !! tasks to be executed contains private procedure , public :: dag procedure , public :: tasks end type interface application_t pure module function construct ( dag , tasks ) result ( application ) implicit none type ( dag_t ), intent ( in ) :: dag type ( task_item_t ), intent ( in ) :: tasks (:) type ( application_t ) application end function end interface interface pure module function dag ( self ) implicit none class ( application_t ), intent ( in ) :: self type ( dag_t ) :: dag end function pure module function tasks ( self ) implicit none class ( application_t ), intent ( in ) :: self type ( task_item_t ), allocatable :: tasks (:) end function end interface end module application_m","tags":"","loc":"sourcefile/application_m.f90.html"},{"title":"final_task_m.f90 – FEATS","text":"This file depends on sourcefile~~final_task_m.f90~~EfferentGraph sourcefile~final_task_m.f90 final_task_m.f90 sourcefile~task_m.f90 task_m.f90 sourcefile~final_task_m.f90->sourcefile~task_m.f90 sourcefile~payload_m.f90 payload_m.f90 sourcefile~final_task_m.f90->sourcefile~payload_m.f90 sourcefile~task_m.f90->sourcefile~payload_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~final_task_m.f90~~AfferentGraph sourcefile~final_task_m.f90 final_task_m.f90 sourcefile~image_s.f90 image_s.f90 sourcefile~image_s.f90->sourcefile~final_task_m.f90 sourcefile~final_task_s.f90 final_task_s.f90 sourcefile~final_task_s.f90->sourcefile~final_task_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules final_task_m Source Code final_task_m.f90 Source Code module final_task_m use payload_m , only : payload_t use task_m , only : task_t implicit none private public :: final_task_t type , extends ( task_t ) :: final_task_t !! A signal to the compute images that all tasks have been completed, !! and thus they can stop waiting for tasks to be assigned. contains procedure :: execute procedure :: is_final_task end type interface module function execute ( self , arguments ) result ( output ) implicit none class ( final_task_t ), intent ( in ) :: self type ( payload_t ), intent ( in ) :: arguments (:) type ( payload_t ) :: output end function pure module function is_final_task ( self ) implicit none class ( final_task_t ), intent ( in ) :: self logical :: is_final_task end function end interface end module","tags":"","loc":"sourcefile/final_task_m.f90.html"},{"title":"task_payload_map_s.f90 – FEATS","text":"This file depends on sourcefile~~task_payload_map_s.f90~~EfferentGraph sourcefile~task_payload_map_s.f90 task_payload_map_s.f90 sourcefile~task_payload_map_m.f90 task_payload_map_m.f90 sourcefile~task_payload_map_s.f90->sourcefile~task_payload_map_m.f90 sourcefile~mailbox_m.f90 mailbox_m.f90 sourcefile~task_payload_map_s.f90->sourcefile~mailbox_m.f90 sourcefile~payload_m.f90 payload_m.f90 sourcefile~task_payload_map_m.f90->sourcefile~payload_m.f90 sourcefile~mailbox_m.f90->sourcefile~payload_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules task_payload_map_s Source Code task_payload_map_s.f90 Source Code submodule ( task_payload_map_m ) task_payload_map_s use mailbox_m , only : mailbox implicit none contains module procedure get_task_ids ids = self % task_ids_ end procedure module procedure constructor if ( size ( task_ids ) /= size ( image_nums )) then error stop \"task_payload_map_t%constructor: mismatched argument lengths\" end if new_map % task_ids_ = task_ids new_map % image_nums_ = image_nums end procedure module procedure get_raw_payload associate ( idx => findloc ( array = self % task_ids_ , value = taskid , dim = 1 )) if ( idx == 0 ) then if ( present ( key_error )) then key_error = . true . else error stop 'task_payload_map_t%get_raw_payload: requested task id not found' end if else associate ( img => self % image_nums_ ( idx ) ) pl = mailbox [ img ]% payloads ( taskid )% payload_ ! work around gfortran bug: direcly access payload_ end associate end if end associate end procedure module procedure get_string_payload character ( len = 1 ), allocatable :: raw (:) integer :: i if ( present ( key_error )) then call self % get_raw_payload ( taskid , raw , key_error ) else call self % get_raw_payload ( taskid , raw ) end if allocate ( character ( len = size ( raw )) :: pl ) do concurrent ( i = 1 : size ( raw )) pl ( i : i ) = raw ( i ) end do end procedure end submodule","tags":"","loc":"sourcefile/task_payload_map_s.f90.html"},{"title":"payload_m.f90 – FEATS","text":"Files dependent on this one sourcefile~~payload_m.f90~~AfferentGraph sourcefile~payload_m.f90 payload_m.f90 sourcefile~task_payload_map_m.f90 task_payload_map_m.f90 sourcefile~task_payload_map_m.f90->sourcefile~payload_m.f90 sourcefile~payload_s.f90 payload_s.f90 sourcefile~payload_s.f90->sourcefile~payload_m.f90 sourcefile~mailbox_m.f90 mailbox_m.f90 sourcefile~mailbox_m.f90->sourcefile~payload_m.f90 sourcefile~task_item_m.f90 task_item_m.f90 sourcefile~task_item_m.f90->sourcefile~payload_m.f90 sourcefile~task_m.f90 task_m.f90 sourcefile~task_item_m.f90->sourcefile~task_m.f90 sourcefile~image_m.f90 image_m.f90 sourcefile~image_m.f90->sourcefile~payload_m.f90 sourcefile~image_m.f90->sourcefile~task_payload_map_m.f90 sourcefile~application_m.f90 application_m.f90 sourcefile~image_m.f90->sourcefile~application_m.f90 sourcefile~task_m.f90->sourcefile~payload_m.f90 sourcefile~final_task_m.f90 final_task_m.f90 sourcefile~final_task_m.f90->sourcefile~payload_m.f90 sourcefile~final_task_m.f90->sourcefile~task_m.f90 sourcefile~task_s.f90 task_s.f90 sourcefile~task_s.f90->sourcefile~task_m.f90 sourcefile~image_s.f90 image_s.f90 sourcefile~image_s.f90->sourcefile~mailbox_m.f90 sourcefile~image_s.f90->sourcefile~task_item_m.f90 sourcefile~image_s.f90->sourcefile~image_m.f90 sourcefile~image_s.f90->sourcefile~final_task_m.f90 sourcefile~task_payload_map_s.f90 task_payload_map_s.f90 sourcefile~task_payload_map_s.f90->sourcefile~task_payload_map_m.f90 sourcefile~task_payload_map_s.f90->sourcefile~mailbox_m.f90 sourcefile~application_m.f90->sourcefile~task_item_m.f90 sourcefile~task_item_s.f90 task_item_s.f90 sourcefile~task_item_s.f90->sourcefile~task_item_m.f90 sourcefile~final_task_s.f90 final_task_s.f90 sourcefile~final_task_s.f90->sourcefile~final_task_m.f90 sourcefile~application_s.f90 application_s.f90 sourcefile~application_s.f90->sourcefile~application_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules payload_m Source Code payload_m.f90 Source Code module payload_m implicit none private public :: payload_t type :: payload_t !! A raw buffer to facilitate data transfer between  images !! !! Facilitates view of the data as either a string or raw bytes. !! Typical usage will be either to !! * produce a string representation of the data, and then parse that string to recover the original data !! * use the `transfer` function to copy the raw bytes of the data private integer ( 1 ), allocatable , public :: payload_ (:) contains private procedure , public :: raw_payload procedure , public :: string_payload end type interface payload_t pure module function from_raw ( payload ) result ( new_payload ) implicit none integer ( 1 ), intent ( in ) :: payload (:) type ( payload_t ) :: new_payload end function pure module function from_string ( payload ) result ( new_payload ) implicit none character ( len =* ), intent ( in ) :: payload type ( payload_t ) :: new_payload end function end interface interface pure module function raw_payload ( self ) implicit none class ( payload_t ), intent ( in ) :: self integer ( 1 ), allocatable :: raw_payload (:) end function pure module function string_payload ( self ) implicit none class ( payload_t ), intent ( in ) :: self character ( len = :), allocatable :: string_payload end function end interface end module","tags":"","loc":"sourcefile/payload_m.f90.html"},{"title":"image_s.f90 – FEATS","text":"This file depends on sourcefile~~image_s.f90~~EfferentGraph sourcefile~image_s.f90 image_s.f90 sourcefile~task_item_m.f90 task_item_m.f90 sourcefile~image_s.f90->sourcefile~task_item_m.f90 sourcefile~mailbox_m.f90 mailbox_m.f90 sourcefile~image_s.f90->sourcefile~mailbox_m.f90 sourcefile~image_m.f90 image_m.f90 sourcefile~image_s.f90->sourcefile~image_m.f90 sourcefile~final_task_m.f90 final_task_m.f90 sourcefile~image_s.f90->sourcefile~final_task_m.f90 sourcefile~task_m.f90 task_m.f90 sourcefile~task_item_m.f90->sourcefile~task_m.f90 sourcefile~payload_m.f90 payload_m.f90 sourcefile~task_item_m.f90->sourcefile~payload_m.f90 sourcefile~mailbox_m.f90->sourcefile~payload_m.f90 sourcefile~application_m.f90 application_m.f90 sourcefile~image_m.f90->sourcefile~application_m.f90 sourcefile~task_payload_map_m.f90 task_payload_map_m.f90 sourcefile~image_m.f90->sourcefile~task_payload_map_m.f90 sourcefile~image_m.f90->sourcefile~payload_m.f90 sourcefile~final_task_m.f90->sourcefile~task_m.f90 sourcefile~final_task_m.f90->sourcefile~payload_m.f90 sourcefile~application_m.f90->sourcefile~task_item_m.f90 sourcefile~task_m.f90->sourcefile~payload_m.f90 sourcefile~task_payload_map_m.f90->sourcefile~payload_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules image_s Source Code image_s.f90 Source Code submodule ( image_m ) image_s use dag_m , only : dag_t use iso_fortran_env , only : event_type use final_task_m , only : final_task_t use mailbox_m , only : payload_list_t , mailbox , mailbox_entry_can_be_freed use task_item_m , only : task_item_t implicit none type ( event_type ), allocatable :: ready_for_next_task (:)[:] type ( event_type ) task_assigned [ * ] integer task_identifier [ * ] !! The ID of the task currently assigned to this image. integer , allocatable :: task_assignment_history (:)[:] !! Records which image did which task. !! Index: task number. Value: image number. logical , allocatable :: task_done (:) integer , parameter :: scheduler_image = 1 integer , parameter :: no_task_assigned = - 1 integer , parameter :: NO_TASK_READY = - 1 integer , parameter :: ALL_TASKS_DONE = - 2 integer , parameter :: NO_IMAGE_READY = - 1 contains module procedure run logical :: tasks_left type ( task_item_t ), allocatable :: tasks (:) type ( dag_t ) :: dag task_identifier = no_task_assigned associate ( n_tasks => size ( application % tasks ()), n_imgs => num_images ()) allocate ( ready_for_next_task ( n_imgs )[ * ]) allocate ( mailbox [ * ]) allocate ( mailbox % payloads ( n_tasks )) sync all allocate ( mailbox_entry_can_be_freed ( n_tasks )[ * ]) mailbox_entry_can_be_freed ( n_tasks ) = . false . allocate ( task_assignment_history ( n_tasks )[ * ]) task_assignment_history = NO_IMAGE_READY if ( this_image () == scheduler_image ) then allocate ( task_done ( n_tasks )) task_done = . false . end if end associate tasks_left = . true . tasks = [ application % tasks (), task_item_t ( final_task_t ())] dag = application % dag () do while ( tasks_left ) if ( this_image () == scheduler_image ) then tasks_left = assign_task ( dag ) else tasks_left = do_work ( tasks , dag ) end if end do results = task_payload_map_t ([ integer :: ], [ integer :: ]) end procedure function do_work ( tasks , dag ) result ( tasks_left ) type ( task_item_t ), intent ( in ) :: tasks (:) type ( dag_t ), intent ( in ) :: dag logical :: tasks_left event post ( ready_for_next_task ( this_image ())[ scheduler_image ]) event wait ( task_assigned ) !! It's probably better to introduce this only after some more testing -- HS !free_unneeded_memory: do concurrent(integer :: l = 0:size(mailbox)) !    if(mailbox_entry_can_be_freed(i)) then !        deallocate(mailbox(i)%payload_) !        mailbox_entry_can_be_freed(i) = .false. !    end if !end do free_unneeded_memory do_assigned_task : associate ( my_task => tasks ( task_identifier )) if (. not . my_task % is_final_task ()) then block integer , allocatable :: upstream_task_nums (:) integer , allocatable :: upstream_task_imagenums (:) integer :: i type ( payload_t ), allocatable :: arguments (:) ! figure out which images have our input data upstream_task_nums = dag % dependencies_for ( task_identifier ) upstream_task_imagenums = & [( task_assignment_history ( upstream_task_nums ( i ))[ scheduler_image ], i = 1 , size ( upstream_task_nums ))] arguments = [ ( payload_t ( mailbox [ upstream_task_imagenums ( i )]% payloads ( upstream_task_nums ( i ))% payload_ ), & i = 1 , size ( upstream_task_nums ) ) ] ! execute task, store result mailbox % payloads ( task_identifier ) = & my_task % execute ( arguments ) end block tasks_left = . true . else tasks_left = . false . end if end associate do_assigned_task end function function find_next_image () result ( next_image ) integer :: next_image , i , ev_count next_image = NO_IMAGE_READY do i = 1 , size ( ready_for_next_task ) if ( i == scheduler_image ) cycle ! no need to check the scheduler image call event_query ( ready_for_next_task ( i ), ev_count ) if ( ev_count > 0 ) then next_image = i associate ( task_just_completed => ( task_identifier [ i ])) if ( task_just_completed /= no_task_assigned ) & task_done ( task_just_completed ) = . true . end associate end if end do end function function assign_task ( dag ) result ( tasks_left ) type ( dag_t ), intent ( in ) :: dag logical :: tasks_left integer , allocatable , dimension (:) :: upstream_tasks , upstream_task_images integer :: i associate ( next_image => find_next_image ()) if ( next_image /= NO_IMAGE_READY ) then associate ( next_task => find_next_task ( dag )) if ( next_task == NO_TASK_READY ) then tasks_left = . true . else if ( next_task == ALL_TASKS_DONE ) then call assign_completed_to_images () tasks_left = . false . else event wait ( ready_for_next_task ( next_image )) task_assignment_history ( next_task ) = next_image ! check which task the image just finished, that's task A ! for each task B upstream of A, walk through that task's downstream dependencies ! if they're all completed, the output data from B can be freed. i = task_identifier [ next_image ] if ( i /= NO_TASK_READY ) then upstream_tasks = dag % dependencies_for ( i ) upstream_task_images = task_assignment_history ( upstream_tasks ) do i = 1 , size ( upstream_tasks ) if ( all ( task_done ( dag % depends_on ( upstream_tasks ( i ))))) then mailbox_entry_can_be_freed ( upstream_tasks ( i ))[ upstream_task_images ( i )] = . true . end if end do end if ! tell the image that it can proceed with the next task task_identifier [ next_image ] = next_task event post ( task_assigned [ next_image ]) tasks_left = . true . end if end associate else tasks_left = . true . end if end associate end function subroutine assign_completed_to_images () integer :: i do i = 1 , size ( ready_for_next_task ) if ( i == scheduler_image ) cycle ! don't wait on the scheduler image event wait ( ready_for_next_task ( i )) associate ( task_just_completed => ( task_identifier [ i ])) if ( task_just_completed /= no_task_assigned ) & task_done ( task_just_completed ) = . true . end associate task_identifier [ i ] = size ( task_done ) + 1 event post ( task_assigned [ i ]) end do end subroutine pure function find_next_task ( dag ) Result ( next_task_to_run ) !! find_next_task: search through the dag to find the next task where its !! dependencies are complete !! !! possible outputs for next_task_to_run !!     - a positive integer signals the next task to run !!     - 'ALL_TASKS_DONE' signals all tasks are done !!     - 'NO_TASK_READY' signals that no tasks are ready to run !! implicit none type ( dag_t ), intent ( in ) :: dag integer :: next_task_to_run integer :: task , depends integer , allocatable , dimension (:) :: dependencies logical :: done , all_done all_done = . true . next_task_to_run = NO_TASK_READY do task = 1 , size ( task_done ) if ( task_done ( task ) . or . task_assignment_history ( task ) /= NO_IMAGE_READY ) then cycle else all_done = . false . dependencies = dag % dependencies_for ( task ) done = . true . do depends = 1 , size ( dependencies ) done = done . and . task_done ( dependencies ( depends )) end do if ( done ) then next_task_to_run = task exit else cycle end if end if end do if ( all_done ) then next_task_to_run = ALL_TASKS_DONE end if end function find_next_task end submodule","tags":"","loc":"sourcefile/image_s.f90.html"},{"title":"task_s.f90 – FEATS","text":"This file depends on sourcefile~~task_s.f90~~EfferentGraph sourcefile~task_s.f90 task_s.f90 sourcefile~task_m.f90 task_m.f90 sourcefile~task_s.f90->sourcefile~task_m.f90 sourcefile~payload_m.f90 payload_m.f90 sourcefile~task_m.f90->sourcefile~payload_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules task_s Source Code task_s.f90 Source Code submodule ( task_m ) task_s implicit none contains module procedure is_final_task is_final_task = . false . end procedure end submodule","tags":"","loc":"sourcefile/task_s.f90.html"},{"title":"task_m.f90 – FEATS","text":"This file depends on sourcefile~~task_m.f90~~EfferentGraph sourcefile~task_m.f90 task_m.f90 sourcefile~payload_m.f90 payload_m.f90 sourcefile~task_m.f90->sourcefile~payload_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~task_m.f90~~AfferentGraph sourcefile~task_m.f90 task_m.f90 sourcefile~task_s.f90 task_s.f90 sourcefile~task_s.f90->sourcefile~task_m.f90 sourcefile~task_item_m.f90 task_item_m.f90 sourcefile~task_item_m.f90->sourcefile~task_m.f90 sourcefile~final_task_m.f90 final_task_m.f90 sourcefile~final_task_m.f90->sourcefile~task_m.f90 sourcefile~application_m.f90 application_m.f90 sourcefile~application_m.f90->sourcefile~task_item_m.f90 sourcefile~task_item_s.f90 task_item_s.f90 sourcefile~task_item_s.f90->sourcefile~task_item_m.f90 sourcefile~image_s.f90 image_s.f90 sourcefile~image_s.f90->sourcefile~task_item_m.f90 sourcefile~image_s.f90->sourcefile~final_task_m.f90 sourcefile~image_m.f90 image_m.f90 sourcefile~image_s.f90->sourcefile~image_m.f90 sourcefile~final_task_s.f90 final_task_s.f90 sourcefile~final_task_s.f90->sourcefile~final_task_m.f90 sourcefile~image_m.f90->sourcefile~application_m.f90 sourcefile~application_s.f90 application_s.f90 sourcefile~application_s.f90->sourcefile~application_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules task_m Source Code task_m.f90 Source Code module task_m !! Define an abstract interface to tasks that the scheduler !! image assigns and that a compute image executes. use payload_m , only : payload_t implicit none private public :: task_t type , abstract :: task_t !! encapsulate task work private contains procedure ( execute_i ), deferred :: execute procedure :: is_final_task end type abstract interface function execute_i ( self , arguments ) result ( output ) !! complete the assigned task import :: task_t , payload_t implicit none class ( task_t ), intent ( in ) :: self type ( payload_t ), intent ( in ) :: arguments (:) type ( payload_t ) :: output end function end interface interface pure module function is_final_task ( self ) !! is this the final task? implicit none class ( task_t ), intent ( in ) :: self logical :: is_final_task end function end interface end module task_m","tags":"","loc":"sourcefile/task_m.f90.html"},{"title":"task_payload_map_m.f90 – FEATS","text":"This file depends on sourcefile~~task_payload_map_m.f90~~EfferentGraph sourcefile~task_payload_map_m.f90 task_payload_map_m.f90 sourcefile~payload_m.f90 payload_m.f90 sourcefile~task_payload_map_m.f90->sourcefile~payload_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~task_payload_map_m.f90~~AfferentGraph sourcefile~task_payload_map_m.f90 task_payload_map_m.f90 sourcefile~image_m.f90 image_m.f90 sourcefile~image_m.f90->sourcefile~task_payload_map_m.f90 sourcefile~task_payload_map_s.f90 task_payload_map_s.f90 sourcefile~task_payload_map_s.f90->sourcefile~task_payload_map_m.f90 sourcefile~image_s.f90 image_s.f90 sourcefile~image_s.f90->sourcefile~image_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules task_payload_map_m Source Code task_payload_map_m.f90 Source Code module task_payload_map_m use payload_m , only : payload_t implicit none private public :: task_payload_map_t type :: task_payload_map_t !! Mapping from a task ID -> the payload that task output private integer , allocatable :: task_ids_ (:) integer , allocatable :: image_nums_ (:) contains private procedure , public :: get_task_ids procedure , public :: get_raw_payload , get_string_payload end type interface task_payload_map_t pure module function constructor ( task_ids , image_nums ) result ( new_map ) implicit none integer , intent ( in ) :: task_ids (:) integer , intent ( in ) :: image_nums (:) type ( task_payload_map_t ) :: new_map end function end interface interface pure module function get_task_ids ( self ) result ( ids ) implicit none class ( task_payload_map_t ), intent ( in ) :: self integer , allocatable :: ids (:) end function pure module subroutine get_raw_payload ( self , taskid , pl , key_error ) implicit none class ( task_payload_map_t ), intent ( in ) :: self integer , intent ( in ) :: taskid character ( len = 1 ), allocatable , intent ( out ) :: pl (:) logical , optional , intent ( out ) :: key_error end subroutine pure module subroutine get_string_payload ( self , taskid , pl , key_error ) implicit none class ( task_payload_map_t ), intent ( in ) :: self integer , intent ( in ) :: taskid character ( len = :), allocatable , intent ( out ) :: pl logical , optional , intent ( out ) :: key_error end subroutine end interface end module","tags":"","loc":"sourcefile/task_payload_map_m.f90.html"},{"title":"application_s.f90 – FEATS","text":"This file depends on sourcefile~~application_s.f90~~EfferentGraph sourcefile~application_s.f90 application_s.f90 sourcefile~application_m.f90 application_m.f90 sourcefile~application_s.f90->sourcefile~application_m.f90 sourcefile~task_item_m.f90 task_item_m.f90 sourcefile~application_m.f90->sourcefile~task_item_m.f90 sourcefile~task_m.f90 task_m.f90 sourcefile~task_item_m.f90->sourcefile~task_m.f90 sourcefile~payload_m.f90 payload_m.f90 sourcefile~task_item_m.f90->sourcefile~payload_m.f90 sourcefile~task_m.f90->sourcefile~payload_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules application_s Source Code application_s.f90 Source Code submodule ( application_m ) application_s use assert_m , only : assert implicit none contains module procedure construct call assert ( size ( tasks ) == dag % num_vertices (), \"application(construct): size(tasks)==dag%num_vertices()\" ) application % dag_ = dag application % tasks_ = tasks end procedure module procedure dag dag = self % dag_ end procedure module procedure tasks tasks = self % tasks_ end procedure end submodule application_s","tags":"","loc":"sourcefile/application_s.f90.html"},{"title":"task_item_m.f90 – FEATS","text":"This file depends on sourcefile~~task_item_m.f90~~EfferentGraph sourcefile~task_item_m.f90 task_item_m.f90 sourcefile~task_m.f90 task_m.f90 sourcefile~task_item_m.f90->sourcefile~task_m.f90 sourcefile~payload_m.f90 payload_m.f90 sourcefile~task_item_m.f90->sourcefile~payload_m.f90 sourcefile~task_m.f90->sourcefile~payload_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~task_item_m.f90~~AfferentGraph sourcefile~task_item_m.f90 task_item_m.f90 sourcefile~application_m.f90 application_m.f90 sourcefile~application_m.f90->sourcefile~task_item_m.f90 sourcefile~task_item_s.f90 task_item_s.f90 sourcefile~task_item_s.f90->sourcefile~task_item_m.f90 sourcefile~image_s.f90 image_s.f90 sourcefile~image_s.f90->sourcefile~task_item_m.f90 sourcefile~image_m.f90 image_m.f90 sourcefile~image_s.f90->sourcefile~image_m.f90 sourcefile~image_m.f90->sourcefile~application_m.f90 sourcefile~application_s.f90 application_s.f90 sourcefile~application_s.f90->sourcefile~application_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules task_item_m Source Code task_item_m.f90 Source Code module task_item_m !! define tasks for compute images to complete use payload_m , only : payload_t use task_m , only : task_t implicit none private public :: task_item_t type task_item_t !! A wrapper for a `class(task_t)` value, to facilitate constructing an array of tasks private class ( task_t ), allocatable :: task contains procedure :: execute procedure :: is_final_task end type interface task_item_t module function constructor ( task ) result ( new_task_item ) implicit none type ( task_item_t ) new_task_item class ( task_t ), intent ( in ) :: task end function end interface interface module function execute ( self , arguments ) result ( output ) !! complete the assigned task implicit none class ( task_item_t ), intent ( in ) :: self type ( payload_t ), intent ( in ) :: arguments (:) type ( payload_t ) :: output end function pure module function is_final_task ( self ) !! is this the final task? implicit none class ( task_item_t ), intent ( in ) :: self logical :: is_final_task end function end interface end module task_item_m","tags":"","loc":"sourcefile/task_item_m.f90.html"},{"title":"mailbox_m.f90 – FEATS","text":"This file depends on sourcefile~~mailbox_m.f90~~EfferentGraph sourcefile~mailbox_m.f90 mailbox_m.f90 sourcefile~payload_m.f90 payload_m.f90 sourcefile~mailbox_m.f90->sourcefile~payload_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mailbox_m.f90~~AfferentGraph sourcefile~mailbox_m.f90 mailbox_m.f90 sourcefile~image_s.f90 image_s.f90 sourcefile~image_s.f90->sourcefile~mailbox_m.f90 sourcefile~task_payload_map_s.f90 task_payload_map_s.f90 sourcefile~task_payload_map_s.f90->sourcefile~mailbox_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules mailbox_m Source Code mailbox_m.f90 Source Code module mailbox_m use payload_m , only : payload_t implicit none private public :: payload_list_t , mailbox , mailbox_entry_can_be_freed type :: payload_list_t type ( payload_t ), allocatable :: payloads (:) end type type ( payload_list_t ), allocatable :: mailbox [:] !! storage for communicating inputs/outputs between tasks logical , allocatable :: mailbox_entry_can_be_freed (:)[:] !! used by the scheduler image to tell the worker images when they can release old data. end module","tags":"","loc":"sourcefile/mailbox_m.f90.html"},{"title":"final_task_s.f90 – FEATS","text":"This file depends on sourcefile~~final_task_s.f90~~EfferentGraph sourcefile~final_task_s.f90 final_task_s.f90 sourcefile~final_task_m.f90 final_task_m.f90 sourcefile~final_task_s.f90->sourcefile~final_task_m.f90 sourcefile~task_m.f90 task_m.f90 sourcefile~final_task_m.f90->sourcefile~task_m.f90 sourcefile~payload_m.f90 payload_m.f90 sourcefile~final_task_m.f90->sourcefile~payload_m.f90 sourcefile~task_m.f90->sourcefile~payload_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules final_task_s Source Code final_task_s.f90 Source Code submodule ( final_task_m ) final_task_s implicit none contains module procedure execute end procedure module procedure is_final_task is_final_task = . true . end procedure end submodule","tags":"","loc":"sourcefile/final_task_s.f90.html"},{"title":"image_m.f90 – FEATS","text":"This file depends on sourcefile~~image_m.f90~~EfferentGraph sourcefile~image_m.f90 image_m.f90 sourcefile~application_m.f90 application_m.f90 sourcefile~image_m.f90->sourcefile~application_m.f90 sourcefile~task_payload_map_m.f90 task_payload_map_m.f90 sourcefile~image_m.f90->sourcefile~task_payload_map_m.f90 sourcefile~payload_m.f90 payload_m.f90 sourcefile~image_m.f90->sourcefile~payload_m.f90 sourcefile~task_item_m.f90 task_item_m.f90 sourcefile~application_m.f90->sourcefile~task_item_m.f90 sourcefile~task_payload_map_m.f90->sourcefile~payload_m.f90 sourcefile~task_item_m.f90->sourcefile~payload_m.f90 sourcefile~task_m.f90 task_m.f90 sourcefile~task_item_m.f90->sourcefile~task_m.f90 sourcefile~task_m.f90->sourcefile~payload_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~image_m.f90~~AfferentGraph sourcefile~image_m.f90 image_m.f90 sourcefile~image_s.f90 image_s.f90 sourcefile~image_s.f90->sourcefile~image_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules image_m Source Code image_m.f90 Source Code module image_m !! Compute-image/Scheduler-image abstraction use application_m , only : application_t use payload_m , only : payload_t use task_payload_map_m , only : task_payload_map_t implicit none private public :: image_t type image_t !! Encapsulate compute/scheduler communication protocol private contains private procedure , public :: run end type interface module function run ( self , application ) result ( results ) implicit none class ( image_t ), intent ( in ) :: self type ( application_t ), intent ( in ) :: application type ( task_payload_map_t ), allocatable :: results end function end interface end module","tags":"","loc":"sourcefile/image_m.f90.html"},{"title":"payload_s.f90 – FEATS","text":"This file depends on sourcefile~~payload_s.f90~~EfferentGraph sourcefile~payload_s.f90 payload_s.f90 sourcefile~payload_m.f90 payload_m.f90 sourcefile~payload_s.f90->sourcefile~payload_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules payload_s Source Code payload_s.f90 Source Code submodule ( payload_m ) payload_s implicit none contains module procedure from_raw new_payload % payload_ = payload end procedure module procedure from_string integer :: i new_payload % payload_ = transfer ( payload ,[ integer ( 1 ) :: ]) end procedure module procedure raw_payload if ( allocated ( self % payload_ )) then raw_payload = self % payload_ else raw_payload = [ integer ( 1 ) :: ] end if end procedure module procedure string_payload integer :: i string_payload = transfer ( self % payload_ , string_payload ) end procedure end submodule","tags":"","loc":"sourcefile/payload_s.f90.html"},{"title":"task_item_s.f90 – FEATS","text":"This file depends on sourcefile~~task_item_s.f90~~EfferentGraph sourcefile~task_item_s.f90 task_item_s.f90 sourcefile~task_item_m.f90 task_item_m.f90 sourcefile~task_item_s.f90->sourcefile~task_item_m.f90 sourcefile~task_m.f90 task_m.f90 sourcefile~task_item_m.f90->sourcefile~task_m.f90 sourcefile~payload_m.f90 payload_m.f90 sourcefile~task_item_m.f90->sourcefile~payload_m.f90 sourcefile~task_m.f90->sourcefile~payload_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules task_item_s Source Code task_item_s.f90 Source Code submodule ( task_item_m ) task_item_s !! define tasks for compute images to complete implicit none contains module procedure execute output = self % task % execute ( arguments ) end procedure module procedure constructor new_task_item % task = task end procedure module procedure is_final_task is_final_task = self % task % is_final_task () end procedure end submodule task_item_s","tags":"","loc":"sourcefile/task_item_s.f90.html"},{"title":"application_t – FEATS ","text":"type, public :: application_t A complete representation of an application that can be executed by FEATS Inherits type~~application_t~~InheritsGraph type~application_t application_t dag_t dag_t type~application_t->dag_t dag_ type~task_item_t task_item_t type~application_t->type~task_item_t tasks_ type~task_t task_t type~task_item_t->type~task_t task Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables dag_ tasks_ Constructor application_t Type-Bound Procedures dag tasks Components Type Visibility Attributes Name Initial type(dag_t), private :: dag_ Describes the dependencies between tasks type( task_item_t ), private, allocatable :: tasks_ (:) tasks to be executed Constructor public interface application_t private pure module function construct(dag, tasks) result(application) Arguments Type Intent Optional Attributes Name type(dag_t), intent(in) :: dag type( task_item_t ), intent(in) :: tasks (:) Return Value type( application_t ) Type-Bound Procedures procedure, public :: dag interface private pure module module function dag(self) Implementation → Arguments Type Intent Optional Attributes Name class( application_t ), intent(in) :: self Return Value type(dag_t) procedure, public :: tasks interface private pure module module function tasks(self) Implementation → Arguments Type Intent Optional Attributes Name class( application_t ), intent(in) :: self Return Value type( task_item_t ),\n  allocatable, (:)","tags":"","loc":"type/application_t.html"},{"title":"final_task_t – FEATS ","text":"type, public, extends( task_t ) :: final_task_t A signal to the compute images that all tasks have been completed,\nand thus they can stop waiting for tasks to be assigned. Inherits type~~final_task_t~~InheritsGraph type~final_task_t final_task_t type~task_t task_t type~final_task_t->type~task_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures execute is_final_task Type-Bound Procedures procedure, public :: execute interface private module module function execute(self, arguments) result(output) Implementation → Arguments Type Intent Optional Attributes Name class( final_task_t ), intent(in) :: self type( payload_t ), intent(in) :: arguments (:) Return Value type( payload_t ) procedure, public :: is_final_task interface private pure module module function is_final_task(self) Implementation → Arguments Type Intent Optional Attributes Name class( final_task_t ), intent(in) :: self Return Value logical","tags":"","loc":"type/final_task_t.html"},{"title":"payload_t – FEATS ","text":"type, public :: payload_t A raw buffer to facilitate data transfer between  images Facilitates view of the data as either a string or raw bytes.\nTypical usage will be either to\n* produce a string representation of the data, and then parse that string to recover the original data\n* use the transfer function to copy the raw bytes of the data Inherited by type~~payload_t~~InheritedByGraph type~payload_t payload_t type~payload_list_t payload_list_t type~payload_list_t->type~payload_t payloads Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables payload_ Constructor payload_t Type-Bound Procedures raw_payload string_payload Components Type Visibility Attributes Name Initial integer(kind=1), public, allocatable :: payload_ (:) Constructor public interface payload_t private pure module function from_raw(payload) result(new_payload) Arguments Type Intent Optional Attributes Name integer(kind=1), intent(in) :: payload (:) Return Value type( payload_t ) private pure module function from_string(payload) result(new_payload) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: payload Return Value type( payload_t ) Type-Bound Procedures procedure, public :: raw_payload interface private pure module module function raw_payload(self) Implementation → Arguments Type Intent Optional Attributes Name class( payload_t ), intent(in) :: self Return Value integer(kind=1),\n  allocatable, (:) procedure, public :: string_payload interface private pure module module function string_payload(self) Implementation → Arguments Type Intent Optional Attributes Name class( payload_t ), intent(in) :: self Return Value character(len=:),\n  allocatable","tags":"","loc":"type/payload_t.html"},{"title":"task_t – FEATS ","text":"type, public, abstract :: task_t encapsulate task work Inherited by type~~task_t~~InheritedByGraph type~task_t task_t type~final_task_t final_task_t type~final_task_t->type~task_t type~task_item_t task_item_t type~task_item_t->type~task_t task type~application_t application_t type~application_t->type~task_item_t tasks_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures execute is_final_task Type-Bound Procedures procedure( execute_i ), public, deferred :: execute function execute_i(self, arguments) result(output) Prototype complete the assigned task Arguments Type Intent Optional Attributes Name class( task_t ), intent(in) :: self type( payload_t ), intent(in) :: arguments (:) Return Value type( payload_t ) procedure, public :: is_final_task interface private pure module module function is_final_task(self) Implementation → is this the final task? Arguments Type Intent Optional Attributes Name class( task_t ), intent(in) :: self Return Value logical","tags":"","loc":"type/task_t.html"},{"title":"task_payload_map_t – FEATS ","text":"type, public :: task_payload_map_t Mapping from a task ID -> the payload that task output Contents Variables image_nums_ task_ids_ Constructor task_payload_map_t Type-Bound Procedures get_raw_payload get_string_payload get_task_ids Components Type Visibility Attributes Name Initial integer, private, allocatable :: image_nums_ (:) integer, private, allocatable :: task_ids_ (:) Constructor public interface task_payload_map_t private pure module function constructor(task_ids, image_nums) result(new_map) Arguments Type Intent Optional Attributes Name integer, intent(in) :: task_ids (:) integer, intent(in) :: image_nums (:) Return Value type( task_payload_map_t ) Type-Bound Procedures procedure, public :: get_raw_payload interface private pure module module subroutine get_raw_payload(self, taskid, pl, key_error) Implementation → Arguments Type Intent Optional Attributes Name class( task_payload_map_t ), intent(in) :: self integer, intent(in) :: taskid character(len=1), intent(out), allocatable :: pl (:) logical, intent(out), optional :: key_error procedure, public :: get_string_payload interface private pure module module subroutine get_string_payload(self, taskid, pl, key_error) Implementation → Arguments Type Intent Optional Attributes Name class( task_payload_map_t ), intent(in) :: self integer, intent(in) :: taskid character(len=:), intent(out), allocatable :: pl logical, intent(out), optional :: key_error procedure, public :: get_task_ids interface private pure module module function get_task_ids(self) result(ids) Implementation → Arguments Type Intent Optional Attributes Name class( task_payload_map_t ), intent(in) :: self Return Value integer,\n  allocatable, (:)","tags":"","loc":"type/task_payload_map_t.html"},{"title":"task_item_t – FEATS ","text":"type, public :: task_item_t A wrapper for a class(task_t) value, to facilitate constructing an array of tasks Inherits type~~task_item_t~~InheritsGraph type~task_item_t task_item_t type~task_t task_t type~task_item_t->type~task_t task Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~task_item_t~~InheritedByGraph type~task_item_t task_item_t type~application_t application_t type~application_t->type~task_item_t tasks_ Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables task Constructor task_item_t Type-Bound Procedures execute is_final_task Components Type Visibility Attributes Name Initial class( task_t ), private, allocatable :: task Constructor public interface task_item_t private module function constructor(task) result(new_task_item) Arguments Type Intent Optional Attributes Name class( task_t ), intent(in) :: task Return Value type( task_item_t ) Type-Bound Procedures procedure, public :: execute interface private module module function execute(self, arguments) result(output) Implementation → complete the assigned task Arguments Type Intent Optional Attributes Name class( task_item_t ), intent(in) :: self type( payload_t ), intent(in) :: arguments (:) Return Value type( payload_t ) procedure, public :: is_final_task interface private pure module module function is_final_task(self) Implementation → is this the final task? Arguments Type Intent Optional Attributes Name class( task_item_t ), intent(in) :: self Return Value logical","tags":"","loc":"type/task_item_t.html"},{"title":"payload_list_t – FEATS ","text":"type, public :: payload_list_t Inherits type~~payload_list_t~~InheritsGraph type~payload_list_t payload_list_t type~payload_t payload_t type~payload_list_t->type~payload_t payloads Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables payloads Components Type Visibility Attributes Name Initial type( payload_t ), private, allocatable :: payloads (:)","tags":"","loc":"type/payload_list_t.html"},{"title":"image_t – FEATS ","text":"type, public :: image_t Encapsulate compute/scheduler communication protocol Contents Type-Bound Procedures run Type-Bound Procedures procedure, public :: run interface private module module function run(self, application) result(results) Implementation → Arguments Type Intent Optional Attributes Name class( image_t ), intent(in) :: self type( application_t ), intent(in) :: application Return Value type( task_payload_map_t ),\n  allocatable","tags":"","loc":"type/image_t.html"},{"title":"execute_i – FEATS","text":"abstract interface private function execute_i(self, arguments) result(output) Arguments Type Intent Optional Attributes Name class( task_t ), intent(in) :: self type( payload_t ), intent(in) :: arguments (:) Return Value type( payload_t ) Description complete the assigned task","tags":"","loc":"interface/execute_i.html"},{"title":"application_t – FEATS","text":"public interface application_t Contents Functions construct Functions private pure module function construct(dag, tasks) result(application) Arguments Type Intent Optional Attributes Name type(dag_t), intent(in) :: dag type( task_item_t ), intent(in) :: tasks (:) Return Value type( application_t )","tags":"","loc":"interface/application_t.html"},{"title":"dag – FEATS","text":"interface Calls interface~~dag~~CallsGraph interface~dag dag proc~dag dag interface~dag->proc~dag Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function dag(self) Implementation → Arguments Type Intent Optional Attributes Name class( application_t ), intent(in) :: self Return Value type(dag_t)","tags":"","loc":"interface/dag.html"},{"title":"tasks – FEATS","text":"interface Calls interface~~tasks~~CallsGraph interface~tasks tasks proc~tasks tasks interface~tasks->proc~tasks Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function tasks(self) Implementation → Arguments Type Intent Optional Attributes Name class( application_t ), intent(in) :: self Return Value type( task_item_t ),\n  allocatable,(:)","tags":"","loc":"interface/tasks.html"},{"title":"execute – FEATS","text":"interface Calls interface~~execute~2~~CallsGraph interface~execute~2 execute proc~execute execute interface~execute~2->proc~execute Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function execute(self, arguments) result(output) Implementation → Arguments Type Intent Optional Attributes Name class( final_task_t ), intent(in) :: self type( payload_t ), intent(in) :: arguments (:) Return Value type( payload_t )","tags":"","loc":"interface/execute~2.html"},{"title":"is_final_task – FEATS","text":"interface Calls interface~~is_final_task~3~~CallsGraph interface~is_final_task~3 is_final_task proc~is_final_task is_final_task interface~is_final_task~3->proc~is_final_task Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function is_final_task(self) Implementation → Arguments Type Intent Optional Attributes Name class( final_task_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/is_final_task~3.html"},{"title":"payload_t – FEATS","text":"public interface payload_t Contents Functions from_raw from_string Functions private pure module function from_raw(payload) result(new_payload) Arguments Type Intent Optional Attributes Name integer(kind=1), intent(in) :: payload (:) Return Value type( payload_t ) private pure module function from_string(payload) result(new_payload) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: payload Return Value type( payload_t )","tags":"","loc":"interface/payload_t.html"},{"title":"raw_payload – FEATS","text":"interface Calls interface~~raw_payload~~CallsGraph interface~raw_payload raw_payload proc~raw_payload raw_payload interface~raw_payload->proc~raw_payload Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function raw_payload(self) Implementation → Arguments Type Intent Optional Attributes Name class( payload_t ), intent(in) :: self Return Value integer(kind=1),\n  allocatable,(:)","tags":"","loc":"interface/raw_payload.html"},{"title":"string_payload – FEATS","text":"interface Calls interface~~string_payload~~CallsGraph interface~string_payload string_payload proc~string_payload string_payload interface~string_payload->proc~string_payload Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function string_payload(self) Implementation → Arguments Type Intent Optional Attributes Name class( payload_t ), intent(in) :: self Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/string_payload.html"},{"title":"assign_task – FEATS","text":"function assign_task(dag) result(tasks_left) Arguments Type Intent Optional Attributes Name type(dag_t), intent(in) :: dag Return Value logical Calls proc~~assign_task~~CallsGraph proc~assign_task assign_task proc~assign_completed_to_images assign_completed_to_images proc~assign_task->proc~assign_completed_to_images Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~assign_task~~CalledByGraph proc~assign_task assign_task proc~run run proc~run->proc~assign_task interface~run run interface~run->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/assign_task.html"},{"title":"do_work – FEATS","text":"function do_work(tasks, dag) result(tasks_left) It's probably better to introduce this only after some more testing -- HS Arguments Type Intent Optional Attributes Name type( task_item_t ), intent(in) :: tasks (:) type(dag_t), intent(in) :: dag Return Value logical Calls proc~~do_work~~CallsGraph proc~do_work do_work upstream_task_nums upstream_task_nums proc~do_work->upstream_task_nums upstream_task_imagenums upstream_task_imagenums proc~do_work->upstream_task_imagenums arguments arguments proc~do_work->arguments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~do_work~~CalledByGraph proc~do_work do_work proc~run run proc~run->proc~do_work interface~run run interface~run->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/do_work.html"},{"title":"find_next_image – FEATS","text":"function find_next_image() result(next_image) Arguments None Return Value integer Calls proc~~find_next_image~~CallsGraph proc~find_next_image find_next_image event_query event_query proc~find_next_image->event_query Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/find_next_image.html"},{"title":"find_next_task – FEATS","text":"pure function find_next_task(dag) result(next_task_to_run) dependencies are complete possible outputs for next_task_to_run\n    - a positive integer signals the next task to run\n    - 'ALL_TASKS_DONE' signals all tasks are done\n    - 'NO_TASK_READY' signals that no tasks are ready to run Arguments Type Intent Optional Attributes Name type(dag_t), intent(in) :: dag Return Value integer Contents Source Code find_next_task Source Code pure function find_next_task ( dag ) Result ( next_task_to_run ) !! find_next_task: search through the dag to find the next task where its !! dependencies are complete !! !! possible outputs for next_task_to_run !!     - a positive integer signals the next task to run !!     - 'ALL_TASKS_DONE' signals all tasks are done !!     - 'NO_TASK_READY' signals that no tasks are ready to run !! implicit none type ( dag_t ), intent ( in ) :: dag integer :: next_task_to_run integer :: task , depends integer , allocatable , dimension (:) :: dependencies logical :: done , all_done all_done = . true . next_task_to_run = NO_TASK_READY do task = 1 , size ( task_done ) if ( task_done ( task ) . or . task_assignment_history ( task ) /= NO_IMAGE_READY ) then cycle else all_done = . false . dependencies = dag % dependencies_for ( task ) done = . true . do depends = 1 , size ( dependencies ) done = done . and . task_done ( dependencies ( depends )) end do if ( done ) then next_task_to_run = task exit else cycle end if end if end do if ( all_done ) then next_task_to_run = ALL_TASKS_DONE end if end function find_next_task","tags":"","loc":"proc/find_next_task.html"},{"title":"assign_completed_to_images – FEATS","text":"subroutine assign_completed_to_images() Arguments None Called by proc~~assign_completed_to_images~~CalledByGraph proc~assign_completed_to_images assign_completed_to_images proc~assign_task assign_task proc~assign_task->proc~assign_completed_to_images proc~run run proc~run->proc~assign_task interface~run run interface~run->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/assign_completed_to_images.html"},{"title":"is_final_task – FEATS","text":"interface Calls interface~~is_final_task~~CallsGraph interface~is_final_task is_final_task proc~is_final_task~2 is_final_task interface~is_final_task->proc~is_final_task~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function is_final_task(self) Implementation → Arguments Type Intent Optional Attributes Name class( task_t ), intent(in) :: self Return Value logical Description is this the final task?","tags":"","loc":"interface/is_final_task.html"},{"title":"task_payload_map_t – FEATS","text":"public interface task_payload_map_t Contents Functions constructor Functions private pure module function constructor(task_ids, image_nums) result(new_map) Arguments Type Intent Optional Attributes Name integer, intent(in) :: task_ids (:) integer, intent(in) :: image_nums (:) Return Value type( task_payload_map_t )","tags":"","loc":"interface/task_payload_map_t.html"},{"title":"get_raw_payload – FEATS","text":"interface Calls interface~~get_raw_payload~~CallsGraph interface~get_raw_payload get_raw_payload proc~get_raw_payload get_raw_payload interface~get_raw_payload->proc~get_raw_payload Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module subroutine get_raw_payload(self, taskid, pl, key_error) Implementation → Arguments Type Intent Optional Attributes Name class( task_payload_map_t ), intent(in) :: self integer, intent(in) :: taskid character(len=1), intent(out), allocatable :: pl (:) logical, intent(out), optional :: key_error","tags":"","loc":"interface/get_raw_payload.html"},{"title":"get_string_payload – FEATS","text":"interface Calls interface~~get_string_payload~~CallsGraph interface~get_string_payload get_string_payload proc~get_string_payload get_string_payload interface~get_string_payload->proc~get_string_payload Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module subroutine get_string_payload(self, taskid, pl, key_error) Implementation → Arguments Type Intent Optional Attributes Name class( task_payload_map_t ), intent(in) :: self integer, intent(in) :: taskid character(len=:), intent(out), allocatable :: pl logical, intent(out), optional :: key_error","tags":"","loc":"interface/get_string_payload.html"},{"title":"get_task_ids – FEATS","text":"interface Calls interface~~get_task_ids~~CallsGraph interface~get_task_ids get_task_ids proc~get_task_ids get_task_ids interface~get_task_ids->proc~get_task_ids Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function get_task_ids(self) result(ids) Implementation → Arguments Type Intent Optional Attributes Name class( task_payload_map_t ), intent(in) :: self Return Value integer,\n  allocatable,(:)","tags":"","loc":"interface/get_task_ids.html"},{"title":"task_item_t – FEATS","text":"public interface task_item_t Contents Functions constructor Functions private module function constructor(task) result(new_task_item) Arguments Type Intent Optional Attributes Name class( task_t ), intent(in) :: task Return Value type( task_item_t )","tags":"","loc":"interface/task_item_t.html"},{"title":"execute – FEATS","text":"interface Calls interface~~execute~~CallsGraph interface~execute execute proc~execute~2 execute interface~execute->proc~execute~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function execute(self, arguments) result(output) Implementation → Arguments Type Intent Optional Attributes Name class( task_item_t ), intent(in) :: self type( payload_t ), intent(in) :: arguments (:) Return Value type( payload_t ) Description complete the assigned task","tags":"","loc":"interface/execute.html"},{"title":"is_final_task – FEATS","text":"interface Calls interface~~is_final_task~2~~CallsGraph interface~is_final_task~2 is_final_task proc~is_final_task~3 is_final_task interface~is_final_task~2->proc~is_final_task~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private pure module module function is_final_task(self) Implementation → Arguments Type Intent Optional Attributes Name class( task_item_t ), intent(in) :: self Return Value logical Description is this the final task?","tags":"","loc":"interface/is_final_task~2.html"},{"title":"run – FEATS","text":"interface Calls interface~~run~~CallsGraph interface~run run proc~run run interface~run->proc~run proc~assign_task assign_task proc~run->proc~assign_task proc~do_work do_work proc~run->proc~do_work proc~assign_completed_to_images assign_completed_to_images proc~assign_task->proc~assign_completed_to_images upstream_task_nums upstream_task_nums proc~do_work->upstream_task_nums upstream_task_imagenums upstream_task_imagenums proc~do_work->upstream_task_imagenums arguments arguments proc~do_work->arguments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module function run(self, application) result(results) Implementation → Arguments Type Intent Optional Attributes Name class( image_t ), intent(in) :: self type( application_t ), intent(in) :: application Return Value type( task_payload_map_t ),\n  allocatable","tags":"","loc":"interface/run.html"},{"title":"constructor – FEATS","text":"module procedure constructor module procedure constructor() Arguments None Contents None","tags":"","loc":"proc/constructor.html"},{"title":"get_raw_payload – FEATS","text":"module procedure get_raw_payload pure module module subroutine get_raw_payload(self, taskid, pl, key_error) Interface → Arguments Type Intent Optional Attributes Name class( task_payload_map_t ), intent(in) :: self integer, intent(in) :: taskid character(len=1), intent(out), allocatable :: pl (:) logical, intent(out), optional :: key_error Called by proc~~get_raw_payload~~CalledByGraph proc~get_raw_payload get_raw_payload interface~get_raw_payload get_raw_payload interface~get_raw_payload->proc~get_raw_payload Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_raw_payload.html"},{"title":"get_string_payload – FEATS","text":"module procedure get_string_payload pure module module subroutine get_string_payload(self, taskid, pl, key_error) Interface → Arguments Type Intent Optional Attributes Name class( task_payload_map_t ), intent(in) :: self integer, intent(in) :: taskid character(len=:), intent(out), allocatable :: pl logical, intent(out), optional :: key_error Called by proc~~get_string_payload~~CalledByGraph proc~get_string_payload get_string_payload interface~get_string_payload get_string_payload interface~get_string_payload->proc~get_string_payload Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_string_payload.html"},{"title":"get_task_ids – FEATS","text":"module procedure get_task_ids pure module module function get_task_ids(self) result(ids) Interface → Arguments Type Intent Optional Attributes Name class( task_payload_map_t ), intent(in) :: self Return Value integer,\n  allocatable,(:) Called by proc~~get_task_ids~~CalledByGraph proc~get_task_ids get_task_ids interface~get_task_ids get_task_ids interface~get_task_ids->proc~get_task_ids Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_task_ids.html"},{"title":"run – FEATS","text":"module procedure run module module function run(self, application) result(results) Interface → Arguments Type Intent Optional Attributes Name class( image_t ), intent(in) :: self type( application_t ), intent(in) :: application Return Value type( task_payload_map_t ),\n  allocatable Calls proc~~run~~CallsGraph proc~run run proc~assign_task assign_task proc~run->proc~assign_task proc~do_work do_work proc~run->proc~do_work proc~assign_completed_to_images assign_completed_to_images proc~assign_task->proc~assign_completed_to_images upstream_task_nums upstream_task_nums proc~do_work->upstream_task_nums upstream_task_imagenums upstream_task_imagenums proc~do_work->upstream_task_imagenums arguments arguments proc~do_work->arguments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~run~~CalledByGraph proc~run run interface~run run interface~run->proc~run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/run.html"},{"title":"is_final_task – FEATS","text":"module procedure is_final_task pure module module function is_final_task(self) Interface → Arguments Type Intent Optional Attributes Name class( task_t ), intent(in) :: self Return Value logical Called by proc~~is_final_task~2~~CalledByGraph proc~is_final_task~2 is_final_task interface~is_final_task is_final_task interface~is_final_task->proc~is_final_task~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/is_final_task~2.html"},{"title":"construct – FEATS","text":"module procedure construct module procedure construct() Arguments None Calls proc~~construct~~CallsGraph proc~construct construct assert assert proc~construct->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct.html"},{"title":"dag – FEATS","text":"module procedure dag pure module module function dag(self) Interface → Arguments Type Intent Optional Attributes Name class( application_t ), intent(in) :: self Return Value type(dag_t) Called by proc~~dag~~CalledByGraph proc~dag dag interface~dag dag interface~dag->proc~dag Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dag.html"},{"title":"tasks – FEATS","text":"module procedure tasks pure module module function tasks(self) Interface → Arguments Type Intent Optional Attributes Name class( application_t ), intent(in) :: self Return Value type( task_item_t ),\n  allocatable,(:) Called by proc~~tasks~~CalledByGraph proc~tasks tasks interface~tasks tasks interface~tasks->proc~tasks Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/tasks.html"},{"title":"execute – FEATS","text":"module procedure execute module module function execute(self, arguments) result(output) Interface → Arguments Type Intent Optional Attributes Name class( final_task_t ), intent(in) :: self type( payload_t ), intent(in) :: arguments (:) Return Value type( payload_t ) Called by proc~~execute~~CalledByGraph proc~execute execute interface~execute~2 execute interface~execute~2->proc~execute Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/execute.html"},{"title":"is_final_task – FEATS","text":"module procedure is_final_task pure module module function is_final_task(self) Interface → Arguments Type Intent Optional Attributes Name class( final_task_t ), intent(in) :: self Return Value logical Called by proc~~is_final_task~~CalledByGraph proc~is_final_task is_final_task interface~is_final_task~3 is_final_task interface~is_final_task~3->proc~is_final_task Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/is_final_task.html"},{"title":"from_raw – FEATS","text":"module procedure from_raw module procedure from_raw() Arguments None Contents None","tags":"","loc":"proc/from_raw.html"},{"title":"from_string – FEATS","text":"module procedure from_string module procedure from_string() Arguments None Contents None","tags":"","loc":"proc/from_string.html"},{"title":"raw_payload – FEATS","text":"module procedure raw_payload pure module module function raw_payload(self) Interface → Arguments Type Intent Optional Attributes Name class( payload_t ), intent(in) :: self Return Value integer(kind=1),\n  allocatable,(:) Called by proc~~raw_payload~~CalledByGraph proc~raw_payload raw_payload interface~raw_payload raw_payload interface~raw_payload->proc~raw_payload Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/raw_payload.html"},{"title":"string_payload – FEATS","text":"module procedure string_payload pure module module function string_payload(self) Interface → Arguments Type Intent Optional Attributes Name class( payload_t ), intent(in) :: self Return Value character(len=:),\n  allocatable Called by proc~~string_payload~~CalledByGraph proc~string_payload string_payload interface~string_payload string_payload interface~string_payload->proc~string_payload Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/string_payload.html"},{"title":"constructor – FEATS","text":"module procedure constructor module procedure constructor() Arguments None Contents None","tags":"","loc":"proc/constructor~2.html"},{"title":"execute – FEATS","text":"module procedure execute module module function execute(self, arguments) result(output) Interface → Arguments Type Intent Optional Attributes Name class( task_item_t ), intent(in) :: self type( payload_t ), intent(in) :: arguments (:) Return Value type( payload_t ) Called by proc~~execute~2~~CalledByGraph proc~execute~2 execute interface~execute execute interface~execute->proc~execute~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/execute~2.html"},{"title":"is_final_task – FEATS","text":"module procedure is_final_task pure module module function is_final_task(self) Interface → Arguments Type Intent Optional Attributes Name class( task_item_t ), intent(in) :: self Return Value logical Called by proc~~is_final_task~3~~CalledByGraph proc~is_final_task~3 is_final_task interface~is_final_task~2 is_final_task interface~is_final_task~2->proc~is_final_task~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/is_final_task~3.html"},{"title":"application_m – FEATS","text":"Uses dag_m task_item_m module~~application_m~~UsesGraph module~application_m application_m dag_m dag_m module~application_m->dag_m module~task_item_m task_item_m module~application_m->module~task_item_m module~task_m task_m module~task_item_m->module~task_m module~payload_m payload_m module~task_item_m->module~payload_m module~task_m->module~payload_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: application_s module~~application_m~~UsedByGraph module~application_m application_m module~application_s application_s module~application_s->module~application_m module~image_m image_m module~image_m->module~application_m module~image_s image_s module~image_s->module~image_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces application_t dag tasks Derived Types application_t Interfaces public interface application_t private pure module function construct(dag, tasks) result(application) Arguments Type Intent Optional Attributes Name type(dag_t), intent(in) :: dag type( task_item_t ), intent(in) :: tasks (:) Return Value type( application_t ) interface private pure module module function dag(self) Implementation → Arguments Type Intent Optional Attributes Name class( application_t ), intent(in) :: self Return Value type(dag_t) interface private pure module module function tasks(self) Implementation → Arguments Type Intent Optional Attributes Name class( application_t ), intent(in) :: self Return Value type( task_item_t ),\n  allocatable, (:) Derived Types type, public :: application_t A complete representation of an application that can be executed by FEATS Components Type Visibility Attributes Name Initial type(dag_t), private :: dag_ Describes the dependencies between tasks type( task_item_t ), private, allocatable :: tasks_ (:) tasks to be executed Constructor private pure,module function construct (dag, tasks) Type-Bound Procedures procedure, public :: dag procedure, public :: tasks","tags":"","loc":"module/application_m.html"},{"title":"final_task_m – FEATS","text":"Uses payload_m task_m module~~final_task_m~~UsesGraph module~final_task_m final_task_m module~task_m task_m module~final_task_m->module~task_m module~payload_m payload_m module~final_task_m->module~payload_m module~task_m->module~payload_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: final_task_s module~~final_task_m~~UsedByGraph module~final_task_m final_task_m module~final_task_s final_task_s module~final_task_s->module~final_task_m module~image_s image_s module~image_s->module~final_task_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces execute is_final_task Derived Types final_task_t Interfaces interface private module module function execute(self, arguments) result(output) Implementation → Arguments Type Intent Optional Attributes Name class( final_task_t ), intent(in) :: self type( payload_t ), intent(in) :: arguments (:) Return Value type( payload_t ) interface private pure module module function is_final_task(self) Implementation → Arguments Type Intent Optional Attributes Name class( final_task_t ), intent(in) :: self Return Value logical Derived Types type, public, extends( task_t ) :: final_task_t A signal to the compute images that all tasks have been completed,\nand thus they can stop waiting for tasks to be assigned. Type-Bound Procedures procedure, public :: execute procedure, public :: is_final_task","tags":"","loc":"module/final_task_m.html"},{"title":"payload_m – FEATS","text":"Used by Descendants: payload_s module~~payload_m~~UsedByGraph module~payload_m payload_m module~mailbox_m mailbox_m module~mailbox_m->module~payload_m module~task_m task_m module~task_m->module~payload_m module~task_payload_map_m task_payload_map_m module~task_payload_map_m->module~payload_m module~task_item_m task_item_m module~task_item_m->module~payload_m module~task_item_m->module~task_m module~payload_s payload_s module~payload_s->module~payload_m module~image_m image_m module~image_m->module~payload_m module~image_m->module~task_payload_map_m module~application_m application_m module~image_m->module~application_m module~final_task_m final_task_m module~final_task_m->module~payload_m module~final_task_m->module~task_m module~application_m->module~task_item_m module~task_s task_s module~task_s->module~task_m module~task_item_s task_item_s module~task_item_s->module~task_item_m module~final_task_s final_task_s module~final_task_s->module~final_task_m module~task_payload_map_s task_payload_map_s module~task_payload_map_s->module~mailbox_m module~task_payload_map_s->module~task_payload_map_m module~image_s image_s module~image_s->module~mailbox_m module~image_s->module~task_item_m module~image_s->module~image_m module~image_s->module~final_task_m module~application_s application_s module~application_s->module~application_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces payload_t raw_payload string_payload Derived Types payload_t Interfaces public interface payload_t private pure module function from_raw(payload) result(new_payload) Arguments Type Intent Optional Attributes Name integer(kind=1), intent(in) :: payload (:) Return Value type( payload_t ) private pure module function from_string(payload) result(new_payload) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: payload Return Value type( payload_t ) interface private pure module module function raw_payload(self) Implementation → Arguments Type Intent Optional Attributes Name class( payload_t ), intent(in) :: self Return Value integer(kind=1),\n  allocatable, (:) interface private pure module module function string_payload(self) Implementation → Arguments Type Intent Optional Attributes Name class( payload_t ), intent(in) :: self Return Value character(len=:),\n  allocatable Derived Types type, public :: payload_t A raw buffer to facilitate data transfer between  images Read more… Components Type Visibility Attributes Name Initial integer(kind=1), public, allocatable :: payload_ (:) Constructor private pure,module function from_raw (payload) private pure,module function from_string (payload) Type-Bound Procedures procedure, public :: raw_payload procedure, public :: string_payload","tags":"","loc":"module/payload_m.html"},{"title":"task_m – FEATS","text":"Define an abstract interface to tasks that the scheduler\nimage assigns and that a compute image executes. Uses payload_m module~~task_m~~UsesGraph module~task_m task_m module~payload_m payload_m module~task_m->module~payload_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: task_s module~~task_m~~UsedByGraph module~task_m task_m module~task_item_m task_item_m module~task_item_m->module~task_m module~task_s task_s module~task_s->module~task_m module~final_task_m final_task_m module~final_task_m->module~task_m module~application_m application_m module~application_m->module~task_item_m module~task_item_s task_item_s module~task_item_s->module~task_item_m module~final_task_s final_task_s module~final_task_s->module~final_task_m module~image_s image_s module~image_s->module~task_item_m module~image_s->module~final_task_m module~image_m image_m module~image_s->module~image_m module~application_s application_s module~application_s->module~application_m module~image_m->module~application_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces is_final_task Abstract Interfaces execute_i Derived Types task_t Interfaces interface private pure module module function is_final_task(self) Implementation → is this the final task? Arguments Type Intent Optional Attributes Name class( task_t ), intent(in) :: self Return Value logical Abstract Interfaces abstract interface private function execute_i(self, arguments) result(output) complete the assigned task Arguments Type Intent Optional Attributes Name class( task_t ), intent(in) :: self type( payload_t ), intent(in) :: arguments (:) Return Value type( payload_t ) Derived Types type, public, abstract :: task_t encapsulate task work Type-Bound Procedures procedure(execute_i), public :: execute procedure, public :: is_final_task","tags":"","loc":"module/task_m.html"},{"title":"task_payload_map_m – FEATS","text":"Uses payload_m module~~task_payload_map_m~~UsesGraph module~task_payload_map_m task_payload_map_m module~payload_m payload_m module~task_payload_map_m->module~payload_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: task_payload_map_s module~~task_payload_map_m~~UsedByGraph module~task_payload_map_m task_payload_map_m module~task_payload_map_s task_payload_map_s module~task_payload_map_s->module~task_payload_map_m module~image_m image_m module~image_m->module~task_payload_map_m module~image_s image_s module~image_s->module~image_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces task_payload_map_t get_raw_payload get_string_payload get_task_ids Derived Types task_payload_map_t Interfaces public interface task_payload_map_t private pure module function constructor(task_ids, image_nums) result(new_map) Arguments Type Intent Optional Attributes Name integer, intent(in) :: task_ids (:) integer, intent(in) :: image_nums (:) Return Value type( task_payload_map_t ) interface private pure module module subroutine get_raw_payload(self, taskid, pl, key_error) Implementation → Arguments Type Intent Optional Attributes Name class( task_payload_map_t ), intent(in) :: self integer, intent(in) :: taskid character(len=1), intent(out), allocatable :: pl (:) logical, intent(out), optional :: key_error interface private pure module module subroutine get_string_payload(self, taskid, pl, key_error) Implementation → Arguments Type Intent Optional Attributes Name class( task_payload_map_t ), intent(in) :: self integer, intent(in) :: taskid character(len=:), intent(out), allocatable :: pl logical, intent(out), optional :: key_error interface private pure module module function get_task_ids(self) result(ids) Implementation → Arguments Type Intent Optional Attributes Name class( task_payload_map_t ), intent(in) :: self Return Value integer,\n  allocatable, (:) Derived Types type, public :: task_payload_map_t Mapping from a task ID -> the payload that task output Components Type Visibility Attributes Name Initial integer, private, allocatable :: image_nums_ (:) integer, private, allocatable :: task_ids_ (:) Constructor private pure,module function constructor (task_ids, image_nums) Type-Bound Procedures procedure, public :: get_raw_payload procedure, public :: get_string_payload procedure, public :: get_task_ids","tags":"","loc":"module/task_payload_map_m.html"},{"title":"task_item_m – FEATS","text":"define tasks for compute images to complete Uses payload_m task_m module~~task_item_m~~UsesGraph module~task_item_m task_item_m module~task_m task_m module~task_item_m->module~task_m module~payload_m payload_m module~task_item_m->module~payload_m module~task_m->module~payload_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: task_item_s module~~task_item_m~~UsedByGraph module~task_item_m task_item_m module~application_m application_m module~application_m->module~task_item_m module~task_item_s task_item_s module~task_item_s->module~task_item_m module~image_s image_s module~image_s->module~task_item_m module~image_m image_m module~image_s->module~image_m module~application_s application_s module~application_s->module~application_m module~image_m->module~application_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces task_item_t execute is_final_task Derived Types task_item_t Interfaces public interface task_item_t private module function constructor(task) result(new_task_item) Arguments Type Intent Optional Attributes Name class( task_t ), intent(in) :: task Return Value type( task_item_t ) interface private module module function execute(self, arguments) result(output) Implementation → complete the assigned task Arguments Type Intent Optional Attributes Name class( task_item_t ), intent(in) :: self type( payload_t ), intent(in) :: arguments (:) Return Value type( payload_t ) interface private pure module module function is_final_task(self) Implementation → is this the final task? Arguments Type Intent Optional Attributes Name class( task_item_t ), intent(in) :: self Return Value logical Derived Types type, public :: task_item_t A wrapper for a class(task_t) value, to facilitate constructing an array of tasks Components Type Visibility Attributes Name Initial class( task_t ), private, allocatable :: task Constructor private module function constructor (task) Type-Bound Procedures procedure, public :: execute procedure, public :: is_final_task","tags":"","loc":"module/task_item_m.html"},{"title":"mailbox_m – FEATS","text":"Uses payload_m module~~mailbox_m~~UsesGraph module~mailbox_m mailbox_m module~payload_m payload_m module~mailbox_m->module~payload_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~mailbox_m~~UsedByGraph module~mailbox_m mailbox_m module~image_s image_s module~image_s->module~mailbox_m module~task_payload_map_s task_payload_map_s module~task_payload_map_s->module~mailbox_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables mailbox mailbox_entry_can_be_freed Derived Types payload_list_t Variables Type Visibility Attributes Name Initial type( payload_list_t ), public, allocatable :: mailbox [:] storage for communicating inputs/outputs between tasks logical, public, allocatable :: mailbox_entry_can_be_freed (:)[:] used by the scheduler image to tell the worker images when they can release old data. Derived Types type, public :: payload_list_t Components Type Visibility Attributes Name Initial type( payload_t ), private, allocatable :: payloads (:)","tags":"","loc":"module/mailbox_m.html"},{"title":"image_m – FEATS","text":"Compute-image/Scheduler-image abstraction Uses task_payload_map_m payload_m application_m module~~image_m~~UsesGraph module~image_m image_m module~application_m application_m module~image_m->module~application_m module~task_payload_map_m task_payload_map_m module~image_m->module~task_payload_map_m module~payload_m payload_m module~image_m->module~payload_m dag_m dag_m module~application_m->dag_m module~task_item_m task_item_m module~application_m->module~task_item_m module~task_payload_map_m->module~payload_m module~task_item_m->module~payload_m module~task_m task_m module~task_item_m->module~task_m module~task_m->module~payload_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: image_s module~~image_m~~UsedByGraph module~image_m image_m module~image_s image_s module~image_s->module~image_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces run Derived Types image_t Interfaces interface private module module function run(self, application) result(results) Implementation → Arguments Type Intent Optional Attributes Name class( image_t ), intent(in) :: self type( application_t ), intent(in) :: application Return Value type( task_payload_map_t ),\n  allocatable Derived Types type, public :: image_t Encapsulate compute/scheduler communication protocol Type-Bound Procedures procedure, public :: run","tags":"","loc":"module/image_m.html"},{"title":"task_payload_map_s – FEATS","text":"Uses mailbox_m Ancestors: task_payload_map_m module~~task_payload_map_s~~UsesGraph module~task_payload_map_s task_payload_map_s module~mailbox_m mailbox_m module~task_payload_map_s->module~mailbox_m module~task_payload_map_m task_payload_map_m module~task_payload_map_s->module~task_payload_map_m module~payload_m payload_m module~mailbox_m->module~payload_m module~task_payload_map_m->module~payload_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures constructor get_raw_payload get_string_payload get_task_ids Module Procedures module procedure constructor module procedure constructor() Arguments None module procedure get_raw_payload pure module module subroutine get_raw_payload(self, taskid, pl, key_error) Interface → Arguments Type Intent Optional Attributes Name class( task_payload_map_t ), intent(in) :: self integer, intent(in) :: taskid character(len=1), intent(out), allocatable :: pl (:) logical, intent(out), optional :: key_error module procedure get_string_payload pure module module subroutine get_string_payload(self, taskid, pl, key_error) Interface → Arguments Type Intent Optional Attributes Name class( task_payload_map_t ), intent(in) :: self integer, intent(in) :: taskid character(len=:), intent(out), allocatable :: pl logical, intent(out), optional :: key_error module procedure get_task_ids pure module module function get_task_ids(self) result(ids) Interface → Arguments Type Intent Optional Attributes Name class( task_payload_map_t ), intent(in) :: self Return Value integer,\n  allocatable, (:)","tags":"","loc":"module/task_payload_map_s.html"},{"title":"image_s – FEATS","text":"Uses iso_fortran_env final_task_m mailbox_m task_item_m dag_m Ancestors: image_m module~~image_s~~UsesGraph module~image_s image_s module~mailbox_m mailbox_m module~image_s->module~mailbox_m module~task_item_m task_item_m module~image_s->module~task_item_m iso_fortran_env iso_fortran_env module~image_s->iso_fortran_env module~image_m image_m module~image_s->module~image_m dag_m dag_m module~image_s->dag_m module~final_task_m final_task_m module~image_s->module~final_task_m module~payload_m payload_m module~mailbox_m->module~payload_m module~task_m task_m module~task_item_m->module~task_m module~task_item_m->module~payload_m module~application_m application_m module~image_m->module~application_m module~task_payload_map_m task_payload_map_m module~image_m->module~task_payload_map_m module~image_m->module~payload_m module~final_task_m->module~task_m module~final_task_m->module~payload_m module~application_m->module~task_item_m module~application_m->dag_m module~task_m->module~payload_m module~task_payload_map_m->module~payload_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ALL_TASKS_DONE NO_IMAGE_READY NO_TASK_READY no_task_assigned ready_for_next_task scheduler_image task_assigned task_assignment_history task_done task_identifier Functions assign_task do_work find_next_image find_next_task Subroutines assign_completed_to_images Module Procedures run Variables Type Visibility Attributes Name Initial integer, private, parameter :: ALL_TASKS_DONE = -2 integer, private, parameter :: NO_IMAGE_READY = -1 integer, private, parameter :: NO_TASK_READY = -1 integer, private, parameter :: no_task_assigned = -1 type(event_type), private, allocatable :: ready_for_next_task (:)[:] integer, private, parameter :: scheduler_image = 1 type(event_type), private :: task_assigned [*] integer, private, allocatable :: task_assignment_history (:)[:] Records which image did which task.\nIndex: task number. Value: image number. logical, private, allocatable :: task_done (:) integer, private :: task_identifier [*] The ID of the task currently assigned to this image. Functions function assign_task (dag) result(tasks_left) Arguments Type Intent Optional Attributes Name type(dag_t), intent(in) :: dag Return Value logical function do_work (tasks, dag) result(tasks_left) It's probably better to introduce this only after some more testing -- HS Arguments Type Intent Optional Attributes Name type( task_item_t ), intent(in) :: tasks (:) type(dag_t), intent(in) :: dag Return Value logical function find_next_image () result(next_image) Arguments None Return Value integer pure function find_next_task (dag) result(next_task_to_run) dependencies are complete Read more… Arguments Type Intent Optional Attributes Name type(dag_t), intent(in) :: dag Return Value integer Subroutines subroutine assign_completed_to_images () Arguments None Module Procedures module procedure run module module function run(self, application) result(results) Interface → Arguments Type Intent Optional Attributes Name class( image_t ), intent(in) :: self type( application_t ), intent(in) :: application Return Value type( task_payload_map_t ),\n  allocatable","tags":"","loc":"module/image_s.html"},{"title":"task_s – FEATS","text":"Uses Ancestors: task_m module~~task_s~~UsesGraph module~task_s task_s module~task_m task_m module~task_s->module~task_m module~payload_m payload_m module~task_m->module~payload_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures is_final_task Module Procedures module procedure is_final_task pure module module function is_final_task(self) Interface → Arguments Type Intent Optional Attributes Name class( task_t ), intent(in) :: self Return Value logical","tags":"","loc":"module/task_s.html"},{"title":"application_s – FEATS","text":"Uses assert_m Ancestors: application_m module~~application_s~~UsesGraph module~application_s application_s module~application_m application_m module~application_s->module~application_m assert_m assert_m module~application_s->assert_m dag_m dag_m module~application_m->dag_m module~task_item_m task_item_m module~application_m->module~task_item_m module~task_m task_m module~task_item_m->module~task_m module~payload_m payload_m module~task_item_m->module~payload_m module~task_m->module~payload_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct dag tasks Module Procedures module procedure construct module procedure construct() Arguments None module procedure dag pure module module function dag(self) Interface → Arguments Type Intent Optional Attributes Name class( application_t ), intent(in) :: self Return Value type(dag_t) module procedure tasks pure module module function tasks(self) Interface → Arguments Type Intent Optional Attributes Name class( application_t ), intent(in) :: self Return Value type( task_item_t ),\n  allocatable, (:)","tags":"","loc":"module/application_s.html"},{"title":"final_task_s – FEATS","text":"Uses Ancestors: final_task_m module~~final_task_s~~UsesGraph module~final_task_s final_task_s module~final_task_m final_task_m module~final_task_s->module~final_task_m module~task_m task_m module~final_task_m->module~task_m module~payload_m payload_m module~final_task_m->module~payload_m module~task_m->module~payload_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures execute is_final_task Module Procedures module procedure execute module module function execute(self, arguments) result(output) Interface → Arguments Type Intent Optional Attributes Name class( final_task_t ), intent(in) :: self type( payload_t ), intent(in) :: arguments (:) Return Value type( payload_t ) module procedure is_final_task pure module module function is_final_task(self) Interface → Arguments Type Intent Optional Attributes Name class( final_task_t ), intent(in) :: self Return Value logical","tags":"","loc":"module/final_task_s.html"},{"title":"payload_s – FEATS","text":"Uses Ancestors: payload_m module~~payload_s~~UsesGraph module~payload_s payload_s module~payload_m payload_m module~payload_s->module~payload_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures from_raw from_string raw_payload string_payload Module Procedures module procedure from_raw module procedure from_raw() Arguments None module procedure from_string module procedure from_string() Arguments None module procedure raw_payload pure module module function raw_payload(self) Interface → Arguments Type Intent Optional Attributes Name class( payload_t ), intent(in) :: self Return Value integer(kind=1),\n  allocatable, (:) module procedure string_payload pure module module function string_payload(self) Interface → Arguments Type Intent Optional Attributes Name class( payload_t ), intent(in) :: self Return Value character(len=:),\n  allocatable","tags":"","loc":"module/payload_s.html"},{"title":"task_item_s – FEATS","text":"define tasks for compute images to complete Uses Ancestors: task_item_m module~~task_item_s~~UsesGraph module~task_item_s task_item_s module~task_item_m task_item_m module~task_item_s->module~task_item_m module~task_m task_m module~task_item_m->module~task_m module~payload_m payload_m module~task_item_m->module~payload_m module~task_m->module~payload_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures constructor execute is_final_task Module Procedures module procedure constructor module procedure constructor() Arguments None module procedure execute module module function execute(self, arguments) result(output) Interface → Arguments Type Intent Optional Attributes Name class( task_item_t ), intent(in) :: self type( payload_t ), intent(in) :: arguments (:) Return Value type( payload_t ) module procedure is_final_task pure module module function is_final_task(self) Interface → Arguments Type Intent Optional Attributes Name class( task_item_t ), intent(in) :: self Return Value logical","tags":"","loc":"module/task_item_s.html"}]}