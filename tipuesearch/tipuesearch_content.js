var tipuesearch = {"pages":[{"title":" FEATS ","text":"FEATS ![Sourcery Institute][sourcery-institute logo]\n\n\nFramework for Extensible Asynchronous Task Scheduling (FEATS)\n=============================================================\n\n[![GitHub license][license img]](./LICENSE)\n[![GitHub release][release img]](https://github.com/sourceryinstitute/FEATS/releases/latest)\n[![Download as PDF][pdf img]](https://md2pdf.herokuapp.com/sourceryinstitute/FEATS/blob/master/README.pdf)\n\n[Overview](#overview) | [Getting Started](#getting-started) | [Documentation](#documentation) | [Dependencies](#dependencies) | [Acknowledgments](#acknowledgments) | [Donate](#donate) Overview FEATS is a project to develop a parallel Fortran 2018 asynchronous, task-scheduling framework for use in a range of applications.\nThe goal is that an application developer need only define their tasks and dependencies between them,\nand the framework takes care of executing the in an efficient manner and performing the communications necessary to provide the output of previous tasks to the next task(s) that need it. Getting Started Please see the example directory for a demonstration use case in which FEATS traverses a DAG that describes the module dependencies within FEATS itself and reports on task completion at each step.\nIn this simple example, the task completion is simply printing what file could have been compiled at the corresponding step.\nNo actual compiling happens, but this use case describes what would happen if FEATS were to be used to enable the Fortran Package Manager [ fpm ] to perform parallel builds. With fpm , the GNU Fortran compiler ([ gfortran ]), and OpenCoarrays installed,\nbuild FEATS and run the example program by executing the following command in a bash -like shell: git clone https://github.com/sourceryinstitute/FEATS\ncd FEATS\nfpm run --example --compiler caf --runner \"cafrun -n 4\" Change 4 above to the number of images that you would like to launch in parallel. Documentation Please visit the FEATS GitHub Pages site to see HTML documentation generated\nwith [ ford ]. Dependencies The [ fpm.toml ] manifest describes the FEATS user and developer dependencies\nand directs fpm to download and build the dependency packages automatically. Testing To build and execute the FEATS test suite, run the following command in a bash -like shell: fpm test --compiler caf --runner \"cafrun -n 4\" Please report any test failures or other issues . Acknowledgments We gratefully acknowledge support from NASA Langley Research Center under contract number 80NSSC20P2246. Donate If you find this software useful, please consider donating code or currency to aid in development efforts. [![GitHub forks](https://img.shields.io/github/forks/sourceryinstitute/FEATS.svg?style=social&label=Fork)](https://github.com/sourceryinstitute/FEATS/fork)\n[![GitHub stars](https://img.shields.io/github/stars/sourceryinstitute/FEATS.svg?style=social&label=Star)](https://github.com/sourceryinstitute/FEATS)\n[![GitHub watchers](https://img.shields.io/github/watchers/sourceryinstitute/FEATS.svg?style=social&label=Watch)](https://github.com/sourceryinstitute/FEATS) Developer Info Damian Rouson, Robert Singleterry, Harris Snyder, and Brad Richardson","tags":"home","loc":"index.html"},{"title":"payload_list_t – FEATS ","text":"type, private :: payload_list_t Inherits type~~payload_list_t~~InheritsGraph type~payload_list_t payload_list_t type~payload_t payload_t type~payload_list_t->type~payload_t payloads Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables payloads Components Type Visibility Attributes Name Initial type( payload_t ), private, allocatable :: payloads (:)","tags":"","loc":"type/payload_list_t.html"},{"title":"task_t – FEATS ","text":"type, public, abstract :: task_t encapsulate task work Inherited by type~~task_t~~InheritedByGraph type~task_t task_t type~vertex_t vertex_t type~vertex_t->type~task_t task type~dag_t dag_t type~dag_t->type~vertex_t vertices Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures execute Type-Bound Procedures procedure( execute_i ), public, deferred :: execute function execute_i(self, arguments) result(output) Prototype complete the assigned task Arguments Type Intent Optional Attributes Name class( task_t ), intent(in) :: self type( payload_t ), intent(in) :: arguments (:) Return Value type( payload_t )","tags":"","loc":"type/task_t.html"},{"title":"dag_t – FEATS ","text":"type, public :: dag_t Encapsulate a graph as an array of vertices, each storing dependency information Inherits type~~dag_t~~InheritsGraph type~dag_t dag_t type~vertex_t vertex_t type~dag_t->type~vertex_t vertices type~task_t task_t type~vertex_t->type~task_t task Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables vertices Constructor dag_t Type-Bound Procedures dependencies_for depends_on Components Type Visibility Attributes Name Initial type( vertex_t ), private, allocatable :: vertices (:) Constructor public interface dag_t private function construct_from_vertices (vertices) result(dag) Construct a dag_t object from an array of (unsorted) vertex_t objects (result contains a topologically sorted index array) Arguments Type Intent Optional Attributes Name type( vertex_t ), intent(in) :: vertices (:) Return Value type( dag_t ) Type-Bound Procedures procedure, public :: dependencies_for private pure function dependencies_for (self, vertex_id) result(dependency_ids) Result is an array of the ids on which vertex_id depends Arguments Type Intent Optional Attributes Name class( dag_t ), intent(in) :: self integer, intent(in) :: vertex_id Return Value integer,allocatable, (:) procedure, public :: depends_on private pure function depends_on (self, vertex_num) result(dependencies) Result is an array of the vertex numbers that depend on on vertex vertex_num Arguments Type Intent Optional Attributes Name class( dag_t ), intent(in) :: self integer, intent(in) :: vertex_num Return Value integer,allocatable, (:)","tags":"","loc":"type/dag_t.html"},{"title":"vertex_t – FEATS ","text":"type, public :: vertex_t Encapsulate a node in a graph comprised of vertices connected by dependencies (edges) Inherits type~~vertex_t~~InheritsGraph type~vertex_t vertex_t type~task_t task_t type~vertex_t->type~task_t task Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~vertex_t~~InheritedByGraph type~vertex_t vertex_t type~dag_t dag_t type~dag_t->type~vertex_t vertices Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables edges task Constructor vertex_t Components Type Visibility Attributes Name Initial integer, private, allocatable :: edges (:) class( task_t ), private, allocatable :: task Constructor public interface vertex_t private function construct (edges, task) result(vertex) Arguments Type Intent Optional Attributes Name integer, intent(in) :: edges (:) class( task_t ), intent(in) :: task Return Value type( vertex_t )","tags":"","loc":"type/vertex_t.html"},{"title":"payload_t – FEATS ","text":"type, public :: payload_t A raw buffer to facilitate data transfer between  images Facilitates view of the data as either a string or raw bytes.\nTypical usage will be either to\n* produce a string representation of the data, and then parse that string to recover the original data\n* use the transfer function to copy the raw bytes of the data Inherited by type~~payload_t~~InheritedByGraph type~payload_t payload_t type~payload_list_t payload_list_t type~payload_list_t->type~payload_t payloads Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables payload_ payload_size Constructor payload_t Type-Bound Procedures raw_payload string_payload Components Type Visibility Attributes Name Initial integer, public :: payload_ (MAX_PAYLOAD_SIZE) integer, private :: payload_size = 0 Constructor public interface payload_t private pure function from_raw (payload) result(new_payload) Arguments Type Intent Optional Attributes Name integer, intent(in) :: payload (:) Return Value type( payload_t ) private pure function from_string (payload) result(new_payload) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: payload Return Value type( payload_t ) public pure function empty_payload () Arguments None Return Value type( payload_t ) Type-Bound Procedures procedure, public :: raw_payload private pure function raw_payload (self) Arguments Type Intent Optional Attributes Name class( payload_t ), intent(in) :: self Return Value integer,allocatable, (:) procedure, public :: string_payload private pure function string_payload (self) Arguments Type Intent Optional Attributes Name class( payload_t ), intent(in) :: self Return Value character(len=:),allocatable","tags":"","loc":"type/payload_t.html"},{"title":"execute_i – FEATS","text":"abstract interface private function execute_i(self, arguments) result(output) Arguments Type Intent Optional Attributes Name class( task_t ), intent(in) :: self type( payload_t ), intent(in) :: arguments (:) Return Value type( payload_t ) Description complete the assigned task","tags":"","loc":"interface/execute_i.html"},{"title":"assign_task – FEATS","text":"private function assign_task(dag) result(tasks_left) Arguments Type Intent Optional Attributes Name type( dag_t ), intent(in) :: dag Return Value logical Calls proc~~assign_task~~CallsGraph proc~assign_task assign_task proc~assign_completed_to_images assign_completed_to_images proc~assign_task->proc~assign_completed_to_images Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~assign_task~~CalledByGraph proc~assign_task assign_task proc~run run proc~run->proc~assign_task Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/assign_task.html"},{"title":"do_work – FEATS","text":"private function do_work(dag) result(tasks_left) It's probably better to introduce this only after some more testing -- HS Arguments Type Intent Optional Attributes Name type( dag_t ), intent(in) :: dag Return Value logical Calls proc~~do_work~~CallsGraph proc~do_work do_work upstream_task_nums upstream_task_nums proc~do_work->upstream_task_nums upstream_task_imagenums upstream_task_imagenums proc~do_work->upstream_task_imagenums arguments arguments proc~do_work->arguments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~do_work~~CalledByGraph proc~do_work do_work proc~run run proc~run->proc~do_work Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/do_work.html"},{"title":"find_next_image – FEATS","text":"private function find_next_image() result(next_image) Arguments None Return Value integer Calls proc~~find_next_image~~CallsGraph proc~find_next_image find_next_image event_query event_query proc~find_next_image->event_query Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/find_next_image.html"},{"title":"find_next_task – FEATS","text":"private pure function find_next_task(dag) result(next_task_to_run) dependencies are complete possible outputs for next_task_to_run\n    - a positive integer signals the next task to run\n    - 'ALL_TASKS_DONE' signals all tasks are done\n    - 'NO_TASK_READY' signals that no tasks are ready to run Arguments Type Intent Optional Attributes Name type( dag_t ), intent(in) :: dag Return Value integer Contents Source Code find_next_task Source Code pure function find_next_task ( dag ) Result ( next_task_to_run ) !! find_next_task: search through the dag to find the next task where its !! dependencies are complete !! !! possible outputs for next_task_to_run !!     - a positive integer signals the next task to run !!     - 'ALL_TASKS_DONE' signals all tasks are done !!     - 'NO_TASK_READY' signals that no tasks are ready to run !! implicit none type ( dag_t ), intent ( in ) :: dag integer :: next_task_to_run integer :: task , depends integer , allocatable , dimension (:) :: dependencies logical :: done , all_done all_done = . true . next_task_to_run = NO_TASK_READY do task = 1 , size ( task_done ) if ( task_done ( task ) . or . task_assignment_history ( task ) /= NO_IMAGE_READY ) then cycle else all_done = . false . dependencies = dag % dependencies_for ( task ) done = . true . do depends = 1 , size ( dependencies ) done = done . and . task_done ( dependencies ( depends )) end do if ( done ) then next_task_to_run = task exit else cycle end if end if end do if ( all_done ) then next_task_to_run = ALL_TASKS_DONE end if end function find_next_task","tags":"","loc":"proc/find_next_task.html"},{"title":"run – FEATS","text":"public subroutine run(dag) Arguments Type Intent Optional Attributes Name type( dag_t ), intent(in) :: dag Calls proc~~run~~CallsGraph proc~run run proc~run_single_image run_single_image proc~run->proc~run_single_image proc~assign_task assign_task proc~run->proc~assign_task proc~do_work do_work proc~run->proc~do_work proc~assign_completed_to_images assign_completed_to_images proc~assign_task->proc~assign_completed_to_images upstream_task_nums upstream_task_nums proc~do_work->upstream_task_nums upstream_task_imagenums upstream_task_imagenums proc~do_work->upstream_task_imagenums arguments arguments proc~do_work->arguments Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/run.html"},{"title":"assign_completed_to_images – FEATS","text":"private subroutine assign_completed_to_images() Arguments None Called by proc~~assign_completed_to_images~~CalledByGraph proc~assign_completed_to_images assign_completed_to_images proc~assign_task assign_task proc~assign_task->proc~assign_completed_to_images proc~run run proc~run->proc~assign_task Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/assign_completed_to_images.html"},{"title":"run_single_image – FEATS","text":"private subroutine run_single_image(dag) Arguments Type Intent Optional Attributes Name type( dag_t ), intent(in) :: dag Called by proc~~run_single_image~~CalledByGraph proc~run_single_image run_single_image proc~run run proc~run->proc~run_single_image Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/run_single_image.html"},{"title":"construct_from_vertices – FEATS","text":"private function construct_from_vertices(vertices) result(dag) Construct a dag_t object from an array of (unsorted) vertex_t objects (result contains a topologically sorted index array) Arguments Type Intent Optional Attributes Name type( vertex_t ), intent(in) :: vertices (:) Return Value type( dag_t ) Called by proc~~construct_from_vertices~~CalledByGraph proc~construct_from_vertices construct_from_vertices interface~dag_t dag_t interface~dag_t->proc~construct_from_vertices Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct_from_vertices.html"},{"title":"dependencies_for – FEATS","text":"private pure function dependencies_for(self, vertex_id) result(dependency_ids) Result is an array of the ids on which vertex_id depends Arguments Type Intent Optional Attributes Name class( dag_t ), intent(in) :: self integer, intent(in) :: vertex_id Return Value integer,allocatable,(:) Contents None","tags":"","loc":"proc/dependencies_for.html"},{"title":"depends_on – FEATS","text":"private pure function depends_on(self, vertex_num) result(dependencies) Result is an array of the vertex numbers that depend on on vertex vertex_num Arguments Type Intent Optional Attributes Name class( dag_t ), intent(in) :: self integer, intent(in) :: vertex_num Return Value integer,allocatable,(:) Contents None","tags":"","loc":"proc/depends_on.html"},{"title":"dag_t – FEATS","text":"public interface dag_t Calls interface~~dag_t~~CallsGraph interface~dag_t dag_t proc~construct_from_vertices construct_from_vertices interface~dag_t->proc~construct_from_vertices Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct_from_vertices Module Procedures private function construct_from_vertices (vertices) result(dag) Construct a dag_t object from an array of (unsorted) vertex_t objects (result contains a topologically sorted index array) Arguments Type Intent Optional Attributes Name type( vertex_t ), intent(in) :: vertices (:) Return Value type( dag_t )","tags":"","loc":"interface/dag_t.html"},{"title":"construct – FEATS","text":"private function construct(edges, task) result(vertex) Arguments Type Intent Optional Attributes Name integer, intent(in) :: edges (:) class( task_t ), intent(in) :: task Return Value type( vertex_t ) Called by proc~~construct~~CalledByGraph proc~construct construct interface~vertex_t vertex_t interface~vertex_t->proc~construct Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/construct.html"},{"title":"vertex_t – FEATS","text":"public interface vertex_t Calls interface~~vertex_t~~CallsGraph interface~vertex_t vertex_t proc~construct construct interface~vertex_t->proc~construct Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures construct Module Procedures private function construct (edges, task) result(vertex) Arguments Type Intent Optional Attributes Name integer, intent(in) :: edges (:) class( task_t ), intent(in) :: task Return Value type( vertex_t )","tags":"","loc":"interface/vertex_t.html"},{"title":"empty_payload – FEATS","text":"public pure function empty_payload() Arguments None Return Value type( payload_t ) Called by proc~~empty_payload~~CalledByGraph proc~empty_payload empty_payload interface~payload_t payload_t interface~payload_t->proc~empty_payload Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/empty_payload.html"},{"title":"from_raw – FEATS","text":"private pure function from_raw(payload) result(new_payload) Arguments Type Intent Optional Attributes Name integer, intent(in) :: payload (:) Return Value type( payload_t ) Called by proc~~from_raw~~CalledByGraph proc~from_raw from_raw interface~payload_t payload_t interface~payload_t->proc~from_raw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/from_raw.html"},{"title":"from_string – FEATS","text":"private pure function from_string(payload) result(new_payload) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: payload Return Value type( payload_t ) Calls proc~~from_string~~CallsGraph proc~from_string from_string string_as_integers string_as_integers proc~from_string->string_as_integers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~from_string~~CalledByGraph proc~from_string from_string interface~payload_t payload_t interface~payload_t->proc~from_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/from_string.html"},{"title":"raw_payload – FEATS","text":"private pure function raw_payload(self) Arguments Type Intent Optional Attributes Name class( payload_t ), intent(in) :: self Return Value integer,allocatable,(:) Contents None","tags":"","loc":"proc/raw_payload.html"},{"title":"string_payload – FEATS","text":"private pure function string_payload(self) Arguments Type Intent Optional Attributes Name class( payload_t ), intent(in) :: self Return Value character(len=:),allocatable Contents None","tags":"","loc":"proc/string_payload.html"},{"title":"payload_t – FEATS","text":"public interface payload_t Calls interface~~payload_t~~CallsGraph interface~payload_t payload_t proc~from_raw from_raw interface~payload_t->proc~from_raw proc~from_string from_string interface~payload_t->proc~from_string proc~empty_payload empty_payload interface~payload_t->proc~empty_payload string_as_integers string_as_integers proc~from_string->string_as_integers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures from_raw from_string empty_payload Module Procedures private pure function from_raw (payload) result(new_payload) Arguments Type Intent Optional Attributes Name integer, intent(in) :: payload (:) Return Value type( payload_t ) private pure function from_string (payload) result(new_payload) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: payload Return Value type( payload_t ) public pure function empty_payload () Arguments None Return Value type( payload_t )","tags":"","loc":"interface/payload_t.html"},{"title":"runner_m – FEATS","text":"Compute-image/Scheduler-image abstraction Uses dag_m iso_fortran_env payload_m module~~runner_m~~UsesGraph module~runner_m runner_m module~dag_m dag_m module~runner_m->module~dag_m module~payload_m payload_m module~runner_m->module~payload_m iso_fortran_env iso_fortran_env module~runner_m->iso_fortran_env module~dag_m->iso_fortran_env module~vertex_m vertex_m module~dag_m->module~vertex_m module~task_m task_m module~vertex_m->module~task_m module~task_m->module~payload_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ALL_TASKS_DONE NO_IMAGE_READY NO_TASK_READY mailbox mailbox_entry_can_be_freed no_task_assigned ready_for_next_task scheduler_image task_assigned task_assignment_history task_done task_identifier Derived Types payload_list_t Functions assign_task do_work find_next_image find_next_task Subroutines run assign_completed_to_images run_single_image Variables Type Visibility Attributes Name Initial integer, private, parameter :: ALL_TASKS_DONE = -2 integer, private, parameter :: NO_IMAGE_READY = -1 integer, private, parameter :: NO_TASK_READY = -1 type( payload_list_t ), private, allocatable :: mailbox [:] storage for communicating inputs/outputs between tasks logical, private, allocatable :: mailbox_entry_can_be_freed (:)[:] used by the scheduler image to tell the worker images when they can release old data. integer, private, parameter :: no_task_assigned = -1 type(event_type), private, allocatable :: ready_for_next_task (:)[:] integer, private, parameter :: scheduler_image = 1 type(event_type), private :: task_assigned [*] integer, private, allocatable :: task_assignment_history (:)[:] Records which image did which task.\nIndex: task number. Value: image number. logical, private, allocatable :: task_done (:) integer, private :: task_identifier [*] The ID of the task currently assigned to this image. Derived Types type, private :: payload_list_t Components Type Visibility Attributes Name Initial type( payload_t ), private, allocatable :: payloads (:) Functions private function assign_task (dag) result(tasks_left) Arguments Type Intent Optional Attributes Name type( dag_t ), intent(in) :: dag Return Value logical private function do_work (dag) result(tasks_left) It's probably better to introduce this only after some more testing -- HS Arguments Type Intent Optional Attributes Name type( dag_t ), intent(in) :: dag Return Value logical private function find_next_image () result(next_image) Arguments None Return Value integer private pure function find_next_task (dag) result(next_task_to_run) dependencies are complete Read more… Arguments Type Intent Optional Attributes Name type( dag_t ), intent(in) :: dag Return Value integer Subroutines public subroutine run (dag) Arguments Type Intent Optional Attributes Name type( dag_t ), intent(in) :: dag private subroutine assign_completed_to_images () Arguments None private subroutine run_single_image (dag) Arguments Type Intent Optional Attributes Name type( dag_t ), intent(in) :: dag","tags":"","loc":"module/runner_m.html"},{"title":"task_m – FEATS","text":"Define an abstract interface to tasks that the scheduler\nimage assigns and that a compute image executes. Uses payload_m module~~task_m~~UsesGraph module~task_m task_m module~payload_m payload_m module~task_m->module~payload_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~task_m~~UsedByGraph module~task_m task_m module~vertex_m vertex_m module~vertex_m->module~task_m module~dag_m dag_m module~dag_m->module~vertex_m module~runner_m runner_m module~runner_m->module~dag_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Abstract Interfaces execute_i Derived Types task_t Abstract Interfaces abstract interface private function execute_i(self, arguments) result(output) complete the assigned task Arguments Type Intent Optional Attributes Name class( task_t ), intent(in) :: self type( payload_t ), intent(in) :: arguments (:) Return Value type( payload_t ) Derived Types type, public, abstract :: task_t encapsulate task work Type-Bound Procedures procedure(execute_i), public :: execute","tags":"","loc":"module/task_m.html"},{"title":"dag_m – FEATS","text":"Uses vertex_m iso_fortran_env module~~dag_m~~UsesGraph module~dag_m dag_m module~vertex_m vertex_m module~dag_m->module~vertex_m iso_fortran_env iso_fortran_env module~dag_m->iso_fortran_env module~task_m task_m module~vertex_m->module~task_m module~payload_m payload_m module~task_m->module~payload_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~dag_m~~UsedByGraph module~dag_m dag_m module~runner_m runner_m module~runner_m->module~dag_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces dag_t Derived Types dag_t Functions construct_from_vertices dependencies_for depends_on Interfaces public interface dag_t private function construct_from_vertices (vertices) result(dag) Construct a dag_t object from an array of (unsorted) vertex_t objects (result contains a topologically sorted index array) Arguments Type Intent Optional Attributes Name type( vertex_t ), intent(in) :: vertices (:) Return Value type( dag_t ) Derived Types type, public :: dag_t Encapsulate a graph as an array of vertices, each storing dependency information Components Type Visibility Attributes Name Initial type( vertex_t ), private, allocatable :: vertices (:) Constructor private  function construct_from_vertices (vertices) Construct a dag_t object from an array of (unsorted) vertex_t objects (result contains a topologically sorted index array) Type-Bound Procedures procedure, public :: dependencies_for procedure, public :: depends_on Functions private function construct_from_vertices (vertices) result(dag) Construct a dag_t object from an array of (unsorted) vertex_t objects (result contains a topologically sorted index array) Arguments Type Intent Optional Attributes Name type( vertex_t ), intent(in) :: vertices (:) Return Value type( dag_t ) private pure function dependencies_for (self, vertex_id) result(dependency_ids) Result is an array of the ids on which vertex_id depends Arguments Type Intent Optional Attributes Name class( dag_t ), intent(in) :: self integer, intent(in) :: vertex_id Return Value integer,allocatable, (:) private pure function depends_on (self, vertex_num) result(dependencies) Result is an array of the vertex numbers that depend on on vertex vertex_num Arguments Type Intent Optional Attributes Name class( dag_t ), intent(in) :: self integer, intent(in) :: vertex_num Return Value integer,allocatable, (:)","tags":"","loc":"module/dag_m.html"},{"title":"vertex_m – FEATS","text":"Uses task_m module~~vertex_m~~UsesGraph module~vertex_m vertex_m module~task_m task_m module~vertex_m->module~task_m module~payload_m payload_m module~task_m->module~payload_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~vertex_m~~UsedByGraph module~vertex_m vertex_m module~dag_m dag_m module~dag_m->module~vertex_m module~runner_m runner_m module~runner_m->module~dag_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces vertex_t Derived Types vertex_t Functions construct Interfaces public interface vertex_t private function construct (edges, task) result(vertex) Arguments Type Intent Optional Attributes Name integer, intent(in) :: edges (:) class( task_t ), intent(in) :: task Return Value type( vertex_t ) Derived Types type, public :: vertex_t Encapsulate a node in a graph comprised of vertices connected by dependencies (edges) Components Type Visibility Attributes Name Initial integer, private, allocatable :: edges (:) class( task_t ), private, allocatable :: task Constructor private  function construct (edges, task) Functions private function construct (edges, task) result(vertex) Arguments Type Intent Optional Attributes Name integer, intent(in) :: edges (:) class( task_t ), intent(in) :: task Return Value type( vertex_t )","tags":"","loc":"module/vertex_m.html"},{"title":"payload_m – FEATS","text":"Used by module~~payload_m~~UsedByGraph module~payload_m payload_m module~task_m task_m module~task_m->module~payload_m module~runner_m runner_m module~runner_m->module~payload_m module~dag_m dag_m module~runner_m->module~dag_m module~vertex_m vertex_m module~vertex_m->module~task_m module~dag_m->module~vertex_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables MAX_PAYLOAD_SIZE Interfaces payload_t Derived Types payload_t Functions empty_payload from_raw from_string raw_payload string_payload Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_PAYLOAD_SIZE = 20002 Interfaces public interface payload_t private pure function from_raw (payload) result(new_payload) Arguments Type Intent Optional Attributes Name integer, intent(in) :: payload (:) Return Value type( payload_t ) private pure function from_string (payload) result(new_payload) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: payload Return Value type( payload_t ) public pure function empty_payload () Arguments None Return Value type( payload_t ) Derived Types type, public :: payload_t A raw buffer to facilitate data transfer between  images Read more… Components Type Visibility Attributes Name Initial integer, public :: payload_ (MAX_PAYLOAD_SIZE) integer, private :: payload_size = 0 Constructor private pure function from_raw (payload) private pure function from_string (payload) public pure function empty_payload () Type-Bound Procedures procedure, public :: raw_payload procedure, public :: string_payload Functions public pure function empty_payload () Arguments None Return Value type( payload_t ) private pure function from_raw (payload) result(new_payload) Arguments Type Intent Optional Attributes Name integer, intent(in) :: payload (:) Return Value type( payload_t ) private pure function from_string (payload) result(new_payload) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: payload Return Value type( payload_t ) private pure function raw_payload (self) Arguments Type Intent Optional Attributes Name class( payload_t ), intent(in) :: self Return Value integer,allocatable, (:) private pure function string_payload (self) Arguments Type Intent Optional Attributes Name class( payload_t ), intent(in) :: self Return Value character(len=:),allocatable","tags":"","loc":"module/payload_m.html"},{"title":"runner_m.f90 – FEATS","text":"This file depends on sourcefile~~runner_m.f90~~EfferentGraph sourcefile~runner_m.f90 runner_m.f90 sourcefile~dag_m.f90 dag_m.f90 sourcefile~runner_m.f90->sourcefile~dag_m.f90 sourcefile~payload_m.f90 payload_m.f90 sourcefile~runner_m.f90->sourcefile~payload_m.f90 sourcefile~vertex_m.f90 vertex_m.f90 sourcefile~dag_m.f90->sourcefile~vertex_m.f90 sourcefile~task_m.f90 task_m.f90 sourcefile~vertex_m.f90->sourcefile~task_m.f90 sourcefile~task_m.f90->sourcefile~payload_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules runner_m Source Code runner_m.f90 Source Code module runner_m !! Compute-image/Scheduler-image abstraction use dag_m , only : dag_t use iso_fortran_env , only : event_type use payload_m , only : payload_t implicit none private public :: run type :: payload_list_t type ( payload_t ), allocatable :: payloads (:) end type type ( payload_list_t ), allocatable :: mailbox [:] !! storage for communicating inputs/outputs between tasks logical , allocatable :: mailbox_entry_can_be_freed (:)[:] !! used by the scheduler image to tell the worker images when they can release old data. type ( event_type ), allocatable :: ready_for_next_task (:)[:] type ( event_type ) task_assigned [ * ] integer task_identifier [ * ] !! The ID of the task currently assigned to this image. integer , allocatable :: task_assignment_history (:)[:] !! Records which image did which task. !! Index: task number. Value: image number. logical , allocatable :: task_done (:) integer , parameter :: scheduler_image = 1 integer , parameter :: no_task_assigned = - 1 integer , parameter :: NO_TASK_READY = - 1 integer , parameter :: ALL_TASKS_DONE = - 2 integer , parameter :: NO_IMAGE_READY = - 1 contains subroutine run ( dag ) implicit none type ( dag_t ), intent ( in ) :: dag logical :: tasks_left if ( num_images () == 1 ) then call run_single_image ( dag ) else task_identifier = no_task_assigned associate ( n_tasks => size ( dag % vertices ), n_imgs => num_images ()) allocate ( ready_for_next_task ( n_imgs )[ * ]) allocate ( mailbox [ * ]) allocate ( mailbox % payloads ( n_tasks )) sync all allocate ( mailbox_entry_can_be_freed ( n_tasks )[ * ]) mailbox_entry_can_be_freed ( n_tasks ) = . false . allocate ( task_assignment_history ( n_tasks )[ * ]) task_assignment_history = NO_IMAGE_READY if ( this_image () == scheduler_image ) then allocate ( task_done ( n_tasks )) task_done = . false . end if end associate tasks_left = . true . do while ( tasks_left ) if ( this_image () == scheduler_image ) then tasks_left = assign_task ( dag ) else tasks_left = do_work ( dag ) end if end do end if end subroutine function do_work ( dag ) result ( tasks_left ) type ( dag_t ), intent ( in ) :: dag logical :: tasks_left event post ( ready_for_next_task ( this_image ())[ scheduler_image ]) event wait ( task_assigned ) !! It's probably better to introduce this only after some more testing -- HS !free_unneeded_memory: do concurrent(integer :: l = 0:size(mailbox)) !    if(mailbox_entry_can_be_freed(i)) then !        deallocate(mailbox(i)%payload_) !        mailbox_entry_can_be_freed(i) = .false. !    end if !end do free_unneeded_memory if ( task_identifier == ALL_TASKS_DONE ) then tasks_left = . false . else do_assigned_task : associate ( my_task => dag % vertices ( task_identifier )% task ) block integer , allocatable :: upstream_task_nums (:) integer , allocatable :: upstream_task_imagenums (:) integer :: i type ( payload_t ), allocatable :: arguments (:) ! figure out which images have our input data upstream_task_nums = dag % dependencies_for ( task_identifier ) upstream_task_imagenums = & [( task_assignment_history ( upstream_task_nums ( i ))[ scheduler_image ], i = 1 , size ( upstream_task_nums ))] arguments = [ ( payload_t ( mailbox [ upstream_task_imagenums ( i )]% payloads ( upstream_task_nums ( i ))% payload_ ), & i = 1 , size ( upstream_task_nums ) ) ] ! execute task, store result mailbox % payloads ( task_identifier ) = & my_task % execute ( arguments ) end block tasks_left = . true . end associate do_assigned_task end if end function function find_next_image () result ( next_image ) integer :: next_image , i , ev_count , task_just_completed next_image = NO_IMAGE_READY do i = 1 , size ( ready_for_next_task ) if ( i == scheduler_image ) cycle ! no need to check the scheduler image call event_query ( ready_for_next_task ( i ), ev_count ) if ( ev_count > 0 ) then next_image = i task_just_completed = ( task_identifier [ i ]) if ( task_just_completed /= no_task_assigned ) & task_done ( task_just_completed ) = . true . end if end do end function function assign_task ( dag ) result ( tasks_left ) type ( dag_t ), intent ( in ) :: dag logical :: tasks_left integer , allocatable , dimension (:) :: upstream_tasks , upstream_task_images integer :: i associate ( next_image => find_next_image ()) if ( next_image /= NO_IMAGE_READY ) then associate ( next_task => find_next_task ( dag )) if ( next_task == NO_TASK_READY ) then tasks_left = . true . else if ( next_task == ALL_TASKS_DONE ) then call assign_completed_to_images () tasks_left = . false . else event wait ( ready_for_next_task ( next_image )) task_assignment_history ( next_task ) = next_image ! check which task the image just finished, that's task A ! for each task B upstream of A, walk through that task's downstream dependencies ! if they're all completed, the output data from B can be freed. i = task_identifier [ next_image ] if ( i /= NO_TASK_READY ) then upstream_tasks = dag % dependencies_for ( i ) upstream_task_images = task_assignment_history ( upstream_tasks ) do i = 1 , size ( upstream_tasks ) if ( all ( task_done ( dag % depends_on ( upstream_tasks ( i ))))) then mailbox_entry_can_be_freed ( upstream_tasks ( i ))[ upstream_task_images ( i )] = . true . end if end do end if ! tell the image that it can proceed with the next task task_identifier [ next_image ] = next_task event post ( task_assigned [ next_image ]) tasks_left = . true . end if end associate else tasks_left = . true . end if end associate end function subroutine assign_completed_to_images () integer :: i , task_just_completed do i = 1 , size ( ready_for_next_task ) if ( i == scheduler_image ) cycle ! don't wait on the scheduler image event wait ( ready_for_next_task ( i )) task_just_completed = task_identifier [ i ] if ( task_just_completed /= no_task_assigned ) & task_done ( task_just_completed ) = . true . task_identifier [ i ] = ALL_TASKS_DONE event post ( task_assigned [ i ]) end do end subroutine pure function find_next_task ( dag ) Result ( next_task_to_run ) !! find_next_task: search through the dag to find the next task where its !! dependencies are complete !! !! possible outputs for next_task_to_run !!     - a positive integer signals the next task to run !!     - 'ALL_TASKS_DONE' signals all tasks are done !!     - 'NO_TASK_READY' signals that no tasks are ready to run !! implicit none type ( dag_t ), intent ( in ) :: dag integer :: next_task_to_run integer :: task , depends integer , allocatable , dimension (:) :: dependencies logical :: done , all_done all_done = . true . next_task_to_run = NO_TASK_READY do task = 1 , size ( task_done ) if ( task_done ( task ) . or . task_assignment_history ( task ) /= NO_IMAGE_READY ) then cycle else all_done = . false . dependencies = dag % dependencies_for ( task ) done = . true . do depends = 1 , size ( dependencies ) done = done . and . task_done ( dependencies ( depends )) end do if ( done ) then next_task_to_run = task exit else cycle end if end if end do if ( all_done ) then next_task_to_run = ALL_TASKS_DONE end if end function find_next_task subroutine run_single_image ( dag ) type ( dag_t ), intent ( in ) :: dag type ( payload_t ), allocatable :: results (:) logical , allocatable :: done (:) associate ( num_tasks => size ( dag % vertices )) allocate ( results ( num_tasks ), done ( num_tasks )) done = . false . do while (. not . all ( done )) associate ( next_task => find_next_task ()) results ( next_task ) = dag % vertices ( next_task )% task % execute ( results ( dag % dependencies_for ( next_task ))) done ( next_task ) = . true . end associate end do end associate contains pure function find_next_task () result ( next_task ) integer :: next_task integer :: task do task = 1 , size ( dag % vertices ) if (. not . done ( task ) . and . all ( done ( dag % dependencies_for ( task )))) then next_task = task return end if end do end function end subroutine end module","tags":"","loc":"sourcefile/runner_m.f90.html"},{"title":"task_m.f90 – FEATS","text":"This file depends on sourcefile~~task_m.f90~~EfferentGraph sourcefile~task_m.f90 task_m.f90 sourcefile~payload_m.f90 payload_m.f90 sourcefile~task_m.f90->sourcefile~payload_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~task_m.f90~~AfferentGraph sourcefile~task_m.f90 task_m.f90 sourcefile~vertex_m.f90 vertex_m.f90 sourcefile~vertex_m.f90->sourcefile~task_m.f90 sourcefile~dag_m.f90 dag_m.f90 sourcefile~dag_m.f90->sourcefile~vertex_m.f90 sourcefile~runner_m.f90 runner_m.f90 sourcefile~runner_m.f90->sourcefile~dag_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules task_m Source Code task_m.f90 Source Code module task_m !! Define an abstract interface to tasks that the scheduler !! image assigns and that a compute image executes. use payload_m , only : payload_t implicit none private public :: task_t type , abstract :: task_t !! encapsulate task work contains procedure ( execute_i ), deferred :: execute end type abstract interface function execute_i ( self , arguments ) result ( output ) !! complete the assigned task import :: task_t , payload_t implicit none class ( task_t ), intent ( in ) :: self type ( payload_t ), intent ( in ) :: arguments (:) type ( payload_t ) :: output end function end interface end module task_m","tags":"","loc":"sourcefile/task_m.f90.html"},{"title":"dag_m.f90 – FEATS","text":"This file depends on sourcefile~~dag_m.f90~~EfferentGraph sourcefile~dag_m.f90 dag_m.f90 sourcefile~vertex_m.f90 vertex_m.f90 sourcefile~dag_m.f90->sourcefile~vertex_m.f90 sourcefile~task_m.f90 task_m.f90 sourcefile~vertex_m.f90->sourcefile~task_m.f90 sourcefile~payload_m.f90 payload_m.f90 sourcefile~task_m.f90->sourcefile~payload_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~dag_m.f90~~AfferentGraph sourcefile~dag_m.f90 dag_m.f90 sourcefile~runner_m.f90 runner_m.f90 sourcefile~runner_m.f90->sourcefile~dag_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules dag_m Source Code dag_m.f90 Source Code module dag_m !! summary: A directed acyclic graph (DAG) abstraction. !! author: Jacob Williams, Damian Rouson, Robert Singleterry, Brad Richardson !! version: v1.0 !! date: 2020-Nov-30 !! license: Copyright (c) 2020, Sourcery Institute, BSD 3-clause license Copyright (c) 2018 Jacob Williams use iso_fortran_env , only : iostat_end use vertex_m , only : vertex_t implicit none private public :: dag_t type :: dag_t !! Encapsulate a graph as an array of vertices, each storing dependency information type ( vertex_t ), allocatable :: vertices (:) contains procedure :: dependencies_for procedure :: depends_on end type interface dag_t module procedure construct_from_vertices end interface contains function construct_from_vertices ( vertices ) result ( dag ) !! Construct a dag_t object from an array of (unsorted) vertex_t objects (result contains a topologically sorted index array) type ( vertex_t ), intent ( in ) :: vertices (:) type ( dag_t ) dag dag % vertices = vertices end function pure function depends_on ( self , vertex_num ) result ( dependencies ) !! Result is an array of the vertex numbers that depend on on vertex vertex_num class ( dag_t ), intent ( in ) :: self integer , intent ( in ) :: vertex_num integer , allocatable :: dependencies (:) allocate ( dependencies ( 0 )) block integer v do v = 1 , size ( self % vertices ) if ( any ( self % vertices ( v )% edges == vertex_num )) dependencies = [ dependencies , v ] end do end block end function pure function dependencies_for ( self , vertex_id ) result ( dependency_ids ) !! Result is an array of the ids on which vertex_id depends class ( dag_t ), intent ( in ) :: self integer , intent ( in ) :: vertex_id integer , allocatable :: dependency_ids (:) dependency_ids = self % vertices ( vertex_id )% edges end function end module dag_m","tags":"","loc":"sourcefile/dag_m.f90.html"},{"title":"vertex_m.f90 – FEATS","text":"This file depends on sourcefile~~vertex_m.f90~~EfferentGraph sourcefile~vertex_m.f90 vertex_m.f90 sourcefile~task_m.f90 task_m.f90 sourcefile~vertex_m.f90->sourcefile~task_m.f90 sourcefile~payload_m.f90 payload_m.f90 sourcefile~task_m.f90->sourcefile~payload_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~vertex_m.f90~~AfferentGraph sourcefile~vertex_m.f90 vertex_m.f90 sourcefile~dag_m.f90 dag_m.f90 sourcefile~dag_m.f90->sourcefile~vertex_m.f90 sourcefile~runner_m.f90 runner_m.f90 sourcefile~runner_m.f90->sourcefile~dag_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules vertex_m Source Code vertex_m.f90 Source Code module vertex_m !! summary: Represent one node in a directed acyclic graph. !! author: Jacob Williams, Damian Rouson, Robert Singleterry, Brad Richardson !! version: v1.0 !! date: 2020-Nov-30 !! license: Copyright (c) 2020-2021, Sourcery Institute, BSD 3-clause license Copyright (c) 2018 Jacob Williams use task_m , only : task_t implicit none private public :: vertex_t type vertex_t !! Encapsulate a node in a graph comprised of vertices connected by dependencies (edges) integer , allocatable :: edges (:) class ( task_t ), allocatable :: task end type interface vertex_t module procedure construct end interface contains function construct ( edges , task ) result ( vertex ) integer , intent ( in ) :: edges (:) class ( task_t ), intent ( in ) :: task type ( vertex_t ) :: vertex vertex % edges = edges vertex % task = task end function end module vertex_m","tags":"","loc":"sourcefile/vertex_m.f90.html"},{"title":"payload_m.f90 – FEATS","text":"Files dependent on this one sourcefile~~payload_m.f90~~AfferentGraph sourcefile~payload_m.f90 payload_m.f90 sourcefile~task_m.f90 task_m.f90 sourcefile~task_m.f90->sourcefile~payload_m.f90 sourcefile~runner_m.f90 runner_m.f90 sourcefile~runner_m.f90->sourcefile~payload_m.f90 sourcefile~dag_m.f90 dag_m.f90 sourcefile~runner_m.f90->sourcefile~dag_m.f90 sourcefile~vertex_m.f90 vertex_m.f90 sourcefile~vertex_m.f90->sourcefile~task_m.f90 sourcefile~dag_m.f90->sourcefile~vertex_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules payload_m Source Code payload_m.f90 Source Code module payload_m implicit none private public :: payload_t , empty_payload integer , parameter :: MAX_PAYLOAD_SIZE = 20002 type :: payload_t !! A raw buffer to facilitate data transfer between  images !! !! Facilitates view of the data as either a string or raw bytes. !! Typical usage will be either to !! * produce a string representation of the data, and then parse that string to recover the original data !! * use the `transfer` function to copy the raw bytes of the data private integer , public :: payload_ ( MAX_PAYLOAD_SIZE ) integer :: payload_size = 0 contains private procedure , public :: raw_payload procedure , public :: string_payload end type interface payload_t module procedure from_raw module procedure from_string module procedure empty_payload end interface contains pure function from_raw ( payload ) result ( new_payload ) implicit none integer , intent ( in ) :: payload (:) type ( payload_t ) :: new_payload integer :: incoming_payload_size incoming_payload_size = size ( payload ) if ( incoming_payload_size > MAX_PAYLOAD_SIZE ) then new_payload % payload_size = MAX_PAYLOAD_SIZE new_payload % payload_ = payload ( 1 : MAX_PAYLOAD_SIZE ) else new_payload % payload_size = incoming_payload_size new_payload % payload_ ( 1 : incoming_payload_size ) = payload end if end function pure function from_string ( payload ) result ( new_payload ) implicit none character ( len =* ), intent ( in ) :: payload type ( payload_t ) :: new_payload new_payload % payload_ ( 1 ) = len ( payload ) associate ( string_as_integers => transfer ( payload , new_payload % payload_ )) if ( size ( string_as_integers ) > MAX_PAYLOAD_SIZE - 1 ) then new_payload % payload_size = MAX_PAYLOAD_SIZE new_payload % payload_ ( 2 : MAX_PAYLOAD_SIZE ) = string_as_integers ( 1 : MAX_PAYLOAD_SIZE - 1 ) else new_payload % payload_size = size ( string_as_integers ) + 1 new_payload % payload_ ( 2 : new_payload % payload_size ) = string_as_integers end if end associate end function pure function empty_payload () implicit none type ( payload_t ) :: empty_payload end function pure function raw_payload ( self ) implicit none class ( payload_t ), intent ( in ) :: self integer , allocatable :: raw_payload (:) raw_payload = self % payload_ ( 1 : self % payload_size ) end function pure function string_payload ( self ) implicit none class ( payload_t ), intent ( in ) :: self character ( len = :), allocatable :: string_payload if ( self % payload_size > 0 ) then allocate ( character ( len = self % payload_ ( 1 )) :: string_payload ) if ( self % payload_ ( 1 ) > 0 ) & string_payload = transfer ( & self % payload_ ( 2 : self % payload_size ), string_payload ) else allocate ( character ( len = 0 ) :: string_payload ) end if end function end module","tags":"","loc":"sourcefile/payload_m.f90.html"}]}